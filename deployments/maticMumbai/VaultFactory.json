{
  "address": "0xB40E8b1468698cf308CD50e8DAD4Fe3e391C88e8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "v",
          "type": "address"
        }
      ],
      "name": "isVault",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "underlying",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_onlyVerified",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_r",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_asset_limit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_total_asset_limit",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "N",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigma",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "alpha",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "omega",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "delta",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "r",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "s",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "steak",
              "type": "uint256"
            }
          ],
          "internalType": "struct MarketManager.MarketParameters",
          "name": "default_params",
          "type": "tuple"
        }
      ],
      "name": "newVault",
      "outputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numVaults",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xd81a0a72bcc9174eff3dc2224ef9c3a1e518fecf6d7e392ec7ca19a7497b559a",
  "receipt": {
    "to": null,
    "from": "0x2C7Cb3cB22Ba9B322af60747017acb06deB10933",
    "contractAddress": "0xB40E8b1468698cf308CD50e8DAD4Fe3e391C88e8",
    "transactionIndex": 0,
    "gasUsed": "5240514",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000020000000000000000080000000000000000000000000000000000000000000000000000100000080000000000000000000200000000000000000000001000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5400db5766ea1e5648d4339522a92db3295b8492fcc649b8d1d1e07aa59507f8",
    "transactionHash": "0xd81a0a72bcc9174eff3dc2224ef9c3a1e518fecf6d7e392ec7ca19a7497b559a",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 30002641,
        "transactionHash": "0xd81a0a72bcc9174eff3dc2224ef9c3a1e518fecf6d7e392ec7ca19a7497b559a",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000002c7cb3cb22ba9b322af60747017acb06deb10933",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000745cdf8c05c5aa2000000000000000000000000000000000000000000000000a84f0321ee2a7d26000000000000000000000000000000000000000000002883fd4a1a9afb656e58000000000000000000000000000000000000000000000000a10935292dce2284000000000000000000000000000000000000000000002884048fe893bbc1c8fa",
        "logIndex": 0,
        "blockHash": "0x5400db5766ea1e5648d4339522a92db3295b8492fcc649b8d1d1e07aa59507f8"
      }
    ],
    "blockNumber": 30002641,
    "cumulativeGasUsed": "5240514",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xda96D4256411235c2B61028c689169DcB95105Df"
  ],
  "numDeployments": 2,
  "solcInputHash": "069373f0b7cc8f3ecfd638e09a965759",
  "metadata": "{\"compiler\":{\"version\":\"0.8.12+commit.f00d7308\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"v\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_onlyVerified\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_asset_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_asset_limit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"omega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"steak\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketManager.MarketParameters\",\"name\":\"default_params\",\"type\":\"tuple\"}],\"name\":\"newVault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\",\"kind\":\"dev\",\"methods\":{\"newVault(address,address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"params\":{\"_asset_limit\":\": max number of shares for a single address\",\"_controller\":\": protocol controller\",\"_onlyVerified\":\": only verified users can mint shares\",\"_r\":\": minimum reputation score to mint shares\",\"_total_asset_limit\":\": max number of shares for entire vault\",\"default_params\":\": default params for markets created by vault\",\"underlying\":\": underlying asset for vault\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"newVault(address,address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"creates vault\"}},\"notice\":\"Anyone can create a vault. These can be users who   a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans) b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers) c) a vault for any long-tailed assets  d) managers who wants leverage for yield opportunities on a specific asset  e) uncollateralized lending platforms that wants to delegate the risk underwriting  etc They need to specify  1. Vault mint conditions-> such as verified LPs(managers) only,  2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers) 3. Vault underlying \",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/factories.sol\":\"VaultFactory\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363731373032353439343737\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/bonds/GBC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n// import {ERC20} from \\\"./aave/Libraries.sol\\\"; \\nimport {SafeCast, FixedPointMath, ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \\n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \\n/// @dev all funds will be handled in the child contract \\ncontract GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using Tick for mapping(uint16 => Tick.Info);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using SafeCast for uint256; \\n\\n\\n    modifier onlyEntry(){\\n        require(entry == msg.sender  ,\\\"Not Entry\\\"); \\n        _;\\n    }\\n    \\n    bool private _mutex;\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    constructor(\\n        address _baseToken,\\n        address _tradeToken\\n        //uint256 _priceDelta\\n        ) {\\n        tradeToken = _tradeToken; \\n        baseToken = _baseToken; \\n        //priceDelta = _priceDelta; \\n        fee =0; \\n        factory = address(0); \\n        tickSpacing = 0; \\n        //Start liquidity \\n        liquidity = 100 * uint128(PRECISION); \\n\\n        owner = msg.sender; \\n    }\\n\\n    address public immutable owner; \\n    uint24 public immutable  fee;\\n    Slot0 public slot0; // global state?\\n    address public immutable  factory;\\n    address public immutable  tradeToken;\\n    address public immutable  baseToken;\\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\\n\\n    uint128 public liquidity;\\n\\n    mapping(uint16 => Tick.Info) public  ticks;\\n\\n    mapping(bytes32 => Position.Info) public  positions;\\n\\n    // mapping(uint16=> PricePoint) Points; \\n\\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\\n    uint256 public constant ROUNDLIMIT = 1e4; \\n    uint256 public constant PRECISION = 1e18; \\n    address public entry; \\n\\n    /// @notice previliged function called by the market maker \\n    /// if he is the one providing all the liquidity \\n    function setLiquidity(uint128 liq) internal  \\n    //onlyEntry\\n    {\\n        liquidity = liq; \\n    }\\n\\n    function setEntry(address _entry) external onlyEntry{\\n        entry = _entry; \\n    }\\n    function lock() external onlyEntry{\\n        slot0.unlocked = !slot0.unlocked; \\n    }\\n\\n    function positionIsFilled(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk\\n    ) \\n        public view returns(bool){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        return (liq>0 && numCross > crossId); \\n    }\\n\\n    function setPriceAndPoint(uint256 price) internal  \\n    //onlyOwner\\n    {\\n        slot0.point = priceToPoint(price);         \\n        slot0.curPrice = price.toUint160(); \\n    }\\n\\n    function getCurPrice() external view returns(uint256){\\n        return slot0.curPrice; \\n    }\\n\\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\\n        return uint256(ticks.oneTimeLiquidity(point)); \\n    }    \\n\\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\\n        return ticks.getNumCross(point, moveUp); \\n    }\\n\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 curPrice;\\n        // the current tick\\n        uint16 point;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n\\n        // Whether liquidity provision is amortized \\n        bool amortized; \\n\\n        // Where to modify liquidity \\n        uint16 modifyLiqPoint; \\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        uint256 amountCalculated;\\n        // current sqrt(price)\\n        uint256 curPrice;\\n        // the tick associated with the current price\\n        uint16 point;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobal;\\n        // amount of input token paid as protocol fee\\n        uint128 protocolFee;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n        uint128 liquidityStart; \\n\\n\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint256 priceStart;\\n        // the next tick to swap to from the current tick in the swap direction\\n        uint16 pointNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // price for the next tick (1/0)\\n        uint256 priceNextLimit;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n\\n        uint128 liqDir; \\n    }\\n\\n    struct swapVars{\\n        uint256 a;\\n        uint256 s; \\n        uint256 b; \\n    }\\n\\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\\n    /// -amountSpecified is in trade if moveUp, else is in base \\n    /// returns amountIn if moveUp, cash, else token\\n    /// returns amountOut if moveUp, token, else cash \\n    function trade(\\n        address recipient, \\n        bool moveUp, \\n        int256 amountSpecified, \\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\\n        console.logString('---New Trade---'); \\n\\n        Slot0 memory slot0Start = slot0; \\n        uint256 pDelta = priceDelta; \\n\\n        SwapState memory state = SwapState({\\n            amountSpecifiedRemaining: amountSpecified, \\n            amountCalculated: 0, \\n            curPrice: uint256(slot0Start.curPrice),\\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\\n            protocolFee: 0, \\n            liquidity: liquidity, \\n            liquidityStart: liquidity,\\n            point: slot0.point\\n            }); \\n        swapVars memory vars = swapVars({\\n            a:0,\\n            b:0,\\n            s:0\\n            });\\n\\n        bool exactInput = amountSpecified > 0;\\n\\n        // increment price by 1/1e18 if at boundary, and go back up a point,\\n        // should be negligible compared to fees TODO \\n        if (mod0(state.curPrice, pDelta) && !moveUp) {\\n            state.curPrice += 1; \\n            state.point = priceToPoint(state.curPrice);\\n            slot0.point = state.point; \\n            slot0Start.point = state.point; \\n        }\\n\\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\\n            StepComputations memory step; \\n\\n            step.priceStart = state.curPrice; \\n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \\n\\n            // Need liquidity for both move up and move down for path independence within a \\n            // given point range. Either one of them should be 0 \\n            step.liqDir = ticks.oneTimeLiquidity(state.point);\\n            vars.a = exactInput \\n                ? inv(state.liquidity + step.liqDir)\\n                : invRoundUp(state.liquidity + step.liqDir); \\n            vars.b = yInt(state.curPrice, moveUp); \\n            vars.s = xMax(state.curPrice, vars.b, vars.a); \\n\\n            //If moveup, amountIn is in cash, amountOut is token and vice versa \\n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\\n                state.curPrice, \\n                step.priceNextLimit,    \\n                state.amountSpecifiedRemaining, \\n                fee, \\n                vars               \\n                ); \\n\\n            {console.log('________'); \\n            console.log('CURPRICE', state.curPrice); \\n            console.log('trading; liquidity, amountleft', state.liquidity); \\n            console.log(uint256(-state.amountSpecifiedRemaining));\\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \\n            console.log('a', vars.a); }\\n            console.log('amountinandout', step.amountIn, step.amountOut); \\n            console.log('s,b', vars.s, vars.b); \\n\\n            if (exactInput){\\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \\n            }\\n            else{\\n                state.amountSpecifiedRemaining += int256(step.amountIn); \\n            }\\n            state.amountCalculated += step.amountOut; \\n\\n            if (state.liquidity>0)\\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \\n\\n            // If next limit reached, cross price range and change slope(liquidity)\\n            if (state.curPrice == step.priceNextLimit){\\n\\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\\n                // Else if crossing DOWN, bids are all filled \\n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \\n\\n                int128 liquidityNet = ticks.cross(\\n                    step.pointNext, \\n                    feeGrowthGlobalBase,\\n                    feeGrowthGlobalTrade\\n                    ); \\n\\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \\n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \\n\\n                if (!moveUp) liquidityNet = -liquidityNet; \\n\\n\\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\\n\\n                state.point = step.pointNext;  \\n            }\\n        }\\n\\n        slot0.curPrice = state.curPrice.toUint160(); \\n        if(state.point != slot0Start.point) slot0.point = state.point; \\n            \\n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\\n\\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \\n            \\n        // (amountIn, amountOut) = exactInput\\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n\\n        (amountIn, amountOut) = exactInput\\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n    }\\n\\n    function placeLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk  \\n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \\n\\n        // Should only accept asks for price above the current point range\\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\\\"ask below prie\\\"); \\n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\\\"bids above prie\\\"); \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        numCross = ticks.getNumCross(point, isAsk); \\n        position.updateLimit(int128(amount), isAsk, numCross); \\n\\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \\n\\n        // If placing bids, need to escrow baseAsset, vice versa \\n        address tokenToEscrow = isAsk? tradeToken : baseToken;\\n\\n        amountToEscrow = isAsk\\n                ? tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    )\\n            \\n                : baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    ); \\n\\n        console.log('amountbid', amountToEscrow); \\n\\n    }\\n\\n    function reduceLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \\\"Can't reduce order for current tick\\\"); \\n\\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\\n\\n        position.updateLimit(-int128(amount), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \\n\\n        address tokenToReturn = isAsk? tradeToken : baseToken;\\n        \\n        amountToReturn = isAsk\\n            ? tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                )\\n         \\n            : baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                );\\n    }\\n\\n    /// @notice called when maker wants to claim when the the price is at the \\n    /// point he submitted the order\\n    function claimPartiallyFilledOrder(\\n        address recipient, \\n        uint16 point,\\n        bool isAsk\\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\\n        Slot0 memory _slot0 = slot0; \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n        require(priceToPoint(uint256(slot0.curPrice)) == point, \\\"Not current price\\\"); \\n\\n        // Assume trying to withdraw all liquidity provided \\n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \\n       \\n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \\n\\n        // Get total trade filled OR remaining\\n        tradeAmount = tradeGivenLiquidity(\\n            pointToPrice(point+1),\\n            _slot0.curPrice, \\n            liqToWithdraw\\n        ); \\n           \\n        // Get total base filled OR remaining \\n        baseAmount = baseGivenLiquidity(\\n            _slot0.curPrice, \\n            pointToPrice(point), \\n            liqToWithdraw\\n            ); \\n\\n    }\\n\\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \\n    /// or crossDown \\n    function claimFilledOrder(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        require(numCross > crossId, \\\"Position not filled\\\");\\n\\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        // Sold to base when asks are filled\\n        if(isAsk) claimedAmount = baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        // Bought when bids are filled so want tradeTokens\\n        else claimedAmount = tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        position.updateLimit(-int128(liq), isAsk, 0); \\n        \\n        // Need to burn AND \\n\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        uint16 pointLower;\\n        uint16 pointUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n\\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\\n    function provide(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount, \\n        bytes calldata data \\n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\\n        require(amount > 0, \\\"0 amount\\\"); \\n\\n        (,  amount0,  amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        //mintCallback\\n\\n    }\\n\\n    function remove(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount\\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\\n\\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: -int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        if(amount0>0 || amount1> 0){\\n            (position.tokensOwed0, position.tokensOwed1) = (\\n                position.tokensOwed0 + amount0,\\n                position.tokensOwed1 + amount1\\n            );\\n        }\\n        return (amount0, amount1); \\n    }\\n\\n    function collect(\\n        address recipient,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\\n\\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\\n\\n        if (amount0 > 0) {\\n            position.tokensOwed0 -= amount0;\\n        }\\n        if (amount1 > 0) {\\n            position.tokensOwed1 -= amount1;\\n        }\\n    }\\n\\n\\n    function _modifyPosition(ModifyPositionParams memory params)\\n    private \\n    returns(\\n        Position.Info storage position, \\n        uint256 baseAmount, \\n        uint256 tradeAmount\\n        )\\n    {\\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\\n\\n        position = _updatePosition(\\n            params.owner,\\n            params.pointLower,\\n            params.pointUpper,\\n            params.liquidityDelta,\\n            _slot0.point\\n        );\\n\\n        if (params.liquidityDelta != 0){\\n            if (_slot0.point < params.pointLower){\\n                // in case where liquidity is just asks waiting to be sold into, \\n                // so need to only provide tradeAsset \\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n            } else if( _slot0.point < params.pointUpper){\\n                uint128 liquidityBefore = liquidity; \\n\\n                // Get total asks to be submitted above current price\\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper),\\n                    _slot0.curPrice, \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Get total bids to be submitted below current price \\n                baseAmount = baseGivenLiquidity(\\n                    _slot0.curPrice, \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Slope changes since current price is in this range \\n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\\n\\n            } else{\\n                // liquidity is just bids waiting to be bought into \\n                baseAmount = baseGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                ); \\n            }\\n        }\\n    }\\n\\n    uint256 public feeGrowthGlobalBase;\\n    uint256 public feeGrowthGlobalTrade;\\n\\n    function _updatePosition(\\n        address owner, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        int128 liquidityDelta, \\n        uint16 point \\n        ) private returns(Position.Info storage position){\\n\\n        position = positions.get(owner, pointLower, pointUpper); \\n\\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \\n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \\n\\n        if(liquidityDelta != 0){\\n\\n            ticks.update(\\n                pointLower, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                false\\n                ); \\n\\n            ticks.update(\\n                pointUpper, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                true\\n                ); \\n        } \\n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \\n    }\\n\\n\\n    mapping(uint16=> int128) dynamicLiq; \\n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\\n        dynamicLiq[point] = liq; \\n    }\\n    function setModifyLiqPoint(uint16 point) internal{\\n        slot0.modifyLiqPoint = point;  \\n    }\\n    function amortizeLiq() internal{\\n        slot0.amortized = true; \\n    }\\n\\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return (p2-p1).mulWadDown(L); \\n    }\\n\\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \\n    }\\n\\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return T.divWadDown(p2-p1); \\n    }\\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \\n    }\\n\\n    function pointToPrice(uint16 point) public pure returns(uint160){\\n        return(uint256(point) * priceDelta).toUint160(); \\n    }\\n\\n    /// @notice will round down to nearest integer \\n    function priceToPoint(uint256 price) public pure returns(uint16){\\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        return (curPrice-b).divWadUp(a); \\n    }\\n\\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\\n    /// the current point\\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\\n        uint16 point = priceToPoint(curPrice); \\n\\n        // If at boundary when moving down, decrement point by one\\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \\n    }\\n\\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\\n        if (moveUp) return uint256(point+1) * pDelta; \\n        else return uint256(point) * pDelta; \\n    }\\n\\n    function inv(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \\n    }\\n    function invRoundUp(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \\n    }\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\\n        return (a%b ==0); \\n    }\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\\n        return  isAsk\\n                ? positions.get(to, point, point+1).askLiq\\n                : positions.get(to, point, point+1).bidLiq; \\n    }\\n\\n}\\n\\nlibrary LinearCurve{\\n    uint256 public constant PRECISION = 1e18; \\n    using FixedPointMath for uint256; \\n\\n\\n    /// @notice Compute results of swap given amount in and params\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// b is 0 and s is curPrice/a during variable liquidity phase\\n    function swapStep(\\n        uint256 curPrice, \\n        uint256 targetPrice, \\n        int256 amountRemaining, \\n        uint24 feePips,    \\n        GranularBondingCurve.swapVars memory vars       \\n        ) \\n        public \\n        pure \\n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\\n\\n        bool moveUp = targetPrice >= curPrice; \\n        bool exactInput = amountRemaining >= 0; \\n\\n        // If move up and exactInput, amountIn is base, amountOut is trade \\n        if (exactInput){\\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\\n\\n            if (moveUp){\\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \\n\\n                // If overshoot go to next point\\n                if (nextPrice >= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out for a given price range is Pdelta / a \\n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \\n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \\n                }            \\n                else {\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }   \\n            }\\n\\n            // amountIn is trade, amountOut is base \\n            else {\\n                // If amount is greater than s, then need to cap it \\n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \\n                // If undershoot go to previous point \\n                if(nextPrice <= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out is area under curve \\n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \\n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \\n\\n                }\\n                else{\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }\\n            }\\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \\n        }\\n\\n        else {\\n            if(moveUp){\\n                uint256 remaining = uint256(-amountRemaining); \\n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \\n\\n                // if overshoot\\n                if(nextPrice>=targetPrice){\\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \\n                    nextPrice = targetPrice; \\n\\n                    // Prevent stuck cases where point is almost filled but not quite \\n                    if(remaining - amountIn<=1e4){\\n                        amountIn = remaining; \\n                    } \\n                }\\n                else amountIn = remaining; \\n\\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\\n\\n            }\\n            else{\\n                //TODO \\n            }\\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\\n            amountOut = amountOut + feeAmount;\\n        }\\n    }\\n\\n\\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n    /// @param amount: amount of base in\\n    /// returns amountDelta wanted token returned \\n    function amountOutGivenIn( \\n        uint256 amount,\\n        uint256 s, \\n        uint256 a, \\n        uint256 b, \\n        bool up) \\n        public \\n        pure \\n        returns(uint256 amountDelta, uint256 resultPrice) {\\n        \\n        // If liquidity is not infinite \\n        if(a > 0){\\n            if (up){\\n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \\n                uint256 y = 2*( a.mulWadDown(amount)); \\n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\\n                uint256 z = (a.mulWadDown(s) + b); \\n                amountDelta = (x_y_sqrt-z).divWadDown(a);\\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \\n            }\\n\\n            else{\\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \\n                amountDelta = amount.mulWadDown(z); \\n                resultPrice = a.mulWadDown(s-amount) + b; \\n            }\\n        }\\n\\n        // When a = 0, infinite liquidity and constant price\\n        else{\\n            amountDelta = amount.divWadDown(b); \\n            resultPrice = b; \\n        }\\n\\n    }\\n\\n    /// @notice calculates area under the curve from s to s+amount\\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n     /// returned in collateral decimals\\n    function areaUnderCurve(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    }\\n    function areaUnderCurveRoundUp(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        // you want area to be big for a given amount \\n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n\\n}\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    using FixedPointMath for uint256;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        uint128 bidCrossId; \\n        uint128 askCrossId; \\n        uint128 askLiq; \\n        uint128 bidLiq; \\n\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // the fees owed to the position owner in token0/token1\\n        uint256 tokensOwed0;\\n        uint256 tokensOwed1;\\n\\n        \\n    }\\n\\n    function updateLimit(\\n        Info storage self,\\n        int128 limitLiqudityDelta, \\n        bool isAsk, \\n        uint128 crossId\\n        ) internal {\\n\\n        if (isAsk) {\\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \\n        } \\n\\n        else {\\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \\n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \\n        }\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        uint16 tickLower,\\n        uint16 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees\\n        uint128 tokensOwed0 = uint128(\\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n        uint128 tokensOwed1 =uint128(\\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n            \\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\\n            self.tokensOwed0 += tokensOwed0;\\n            self.tokensOwed1 += tokensOwed1;\\n        }\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n}\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using FixedPointMath for uint256;\\n\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutsideBase;\\n        uint256 feeGrowthOutsideTrade;\\n        // the cumulative tick value on the other side of the tick\\n        int56 tickCumulativeOutside;\\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint160 secondsPerLiquidityOutsideX128;\\n        // the seconds spent on the other side of the tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint32 secondsOutside;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n\\n        uint128 askLiquidityGross; \\n        uint128 bidLiquidityGross;\\n        uint128 askNumCross; \\n        uint128 bidNumCross; \\n    }\\n\\n    function getNumCross(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal view returns(uint128){\\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \\n    }\\n\\n    function oneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick \\n        ) internal view returns(uint128){\\n        Tick.Info memory info = self[tick]; \\n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \\n        return info.askLiquidityGross + info.bidLiquidityGross; \\n    }\\n\\n    function deleteOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal {\\n        Tick.Info storage info = self[tick]; \\n        if(isAsk) {\\n            info.askLiquidityGross = 0;\\n            info.askNumCross++; \\n            console.log('tick??', tick); \\n        }\\n        else {\\n            info.bidLiquidityGross = 0; \\n            info.bidNumCross++; \\n        }\\n    }\\n\\n    function updateOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        int128 oneTimeLiquidityDelta,\\n        bool isAsk\\n        ) internal {\\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \\n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\\n    }\\n\\n    function update(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick,\\n        uint16 tickCurrent,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthGlobalBase, \\n        uint256 feeGrowthGlobalTrade, \\n        bool upper\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross; \\n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if(liquidityGrossBefore == 0) {\\n            if(tick<=tickCurrent){\\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \\n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \\n            }\\n            info.initialized = true; \\n        }\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        info.liquidityNet = upper \\n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \\n    }\\n\\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\\n        delete self[tick];\\n    }\\n\\n    function cross(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick, \\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick]; \\n\\n        liquidityNet = info.liquidityNet; \\n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \\n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint16 tickCurrent,\\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\\n        Info storage lower = self[tickLower];\\n        Info storage upper = self[tickUpper];\\n\\n        // calculate fee growth below\\n        uint256 feeGrowthBelowBase;\\n        uint256 feeGrowthBelowTrade;\\n        if (tickCurrent >= tickLower) {\\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\\n        }\\n\\n        // calculate fee growth above\\n        uint256 feeGrowthAboveBase;\\n        uint256 feeGrowthAboveTrade;\\n        if (tickCurrent < tickUpper) {\\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\\n        }\\n\\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\\n    }\\n}\\n\\n\\ncontract SpotPool is GranularBondingCurve{\\n\\n    ERC20 BaseToken; //junior\\n    ERC20 TradeToken; //senior \\n    // GranularBondingCurve public pool; \\n\\n    constructor(\\n        address _baseToken, \\n        address _tradeToken\\n        )GranularBondingCurve(_baseToken,_tradeToken){\\n        BaseToken = ERC20(_baseToken); \\n        TradeToken = ERC20(_tradeToken); \\n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \\n    }\\n\\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\\n\\n        if(up){\\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\\n            console.log('togive', amountOut, amountIn); \\n            TradeToken.transfer(recipient, amountOut); \\n            console.log('balofre', BaseToken.balanceOf(recipient));\\n            BaseToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n\\n        else{\\n            BaseToken.transfer(recipient, amountOut); \\n            TradeToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n    }\\n\\n    // function getCurPrice() external view returns(uint256){\\n    //     return uint256(pool.getCurPrice());\\n    // }\\n\\n    /// @notice if buyTradeForBase, move up, and vice versa \\n    function takerTrade(\\n        address recipient, \\n        bool buyTradeForBase, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data        \\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        (poolamountIn, poolamountOut) = this.trade(\\n            recipient, \\n            buyTradeForBase, \\n            amountIn,  \\n            priceLimit, \\n            data\\n        ); \\n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \\n    }\\n\\n    /// @notice specify how much trade trader intends to sell/buy \\n    function makerTrade(\\n        bool buyTradeForBase,\\n        uint256 amountIn,\\n        uint16 point\\n        ) external {\\n        (uint256 toEscrowAmount, uint128 crossId) \\n                = this.placeLimitOrder(msg.sender, \\n                    point, \\n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \\n                    !buyTradeForBase); \\n\\n        // Collateral for bids\\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n\\n        // or asks\\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n    }\\n\\n    function makerClaim(\\n        uint16 point, \\n        bool buyTradeForBase\\n        ) external {\\n        uint256 claimedAmount = this.claimFilledOrder(\\n            msg.sender, \\n            point, \\n            !buyTradeForBase\\n        ); \\n\\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\\n        else BaseToken.transfer(msg.sender, claimedAmount); \\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x10039ee3eecf56b8891ccc2d1c996baa0510a53f24f13a9d9a6b50ba3129f821\",\"license\":\"UNLICENSED\"},\"contracts/bonds/boundedDerivatives.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport \\\"./GBC.sol\\\"; \\n// import {BoundedDerivativesPool, LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice Uses AMM as a derivatives market,where the price is bounded between two price\\n/// and mints/burns tradeTokens. \\n/// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \\n/// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \\ncontract BoundedDerivativesPool is GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using SafeCast for uint256; \\n    // using Position for Position.Info;\\n    // uint256 constant PRECISION = 1e18; \\n    ERC20 public  BaseToken; \\n    ERC20 public  TradeToken; \\n    ERC20 public  s_tradeToken; \\n    uint256 public constant maxPrice = 1e18; \\n\\n    bool immutable noCallBack; \\n    constructor(\\n        address base, \\n        address trade, \\n        address s_trade, \\n        bool _noCallBack\\n        // address _pool \\n        ) GranularBondingCurve(base, trade){\\n        BaseToken =  ERC20(base);\\n        TradeToken = ERC20(trade);\\n        s_tradeToken = ERC20(s_trade);\\n        noCallBack = _noCallBack; \\n    }\\n\\n    /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\\n    function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        \\n        // Mint and Pull \\n        if(isLong) TradeToken.mint(recipient, amountOut); \\n        else s_tradeToken.mint(recipient, amountOut); \\n        BaseToken.transferFrom(recipient,address(this), amountIn); \\n    }\\n\\n    function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        // Burn and Push \\n        if(isLong) TradeToken.burn(recipient, amountIn); \\n        else s_tradeToken.burn(recipient, amountIn); \\n   \\n        BaseToken.transfer(recipient, amountOut); \\n    }\\n\\n    function baseBal() public view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n\\n    /// @notice Long up the curve, or short down the curve \\n    /// @param amountIn is base if long, trade if short\\n    /// @param priceLimit is slippage tolerance\\n    function takerOpen(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\\n        if(isLong){\\n            // Buy up \\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else {\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \\n                require(baseBal() >= poolamountIn + bal, \\\"balERR\\\"); \\n                TradeToken.mint(abi.decode(data, (address)), poolamountOut); \\n            }\\n        }\\n\\n        else{\\n            // just shift pool state\\n            (poolamountIn, poolamountOut) = trade(\\n                address(this), \\n                false, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountOut = poolamountOut; \\n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\\n            poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\\n\\n            // One s_tradeToken is a representation of debt+sell of one tradetoken\\n            // Escrow collateral required for shorting, where price for long + short = maxPrice, \\n            // so (maxPrice-price of trade) * quantity\\n            if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\\n\\n            else{\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \\n                require(baseBal() >= poolamountOut + bal, \\\"balERR\\\"); \\n                s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \\n\\n                // need to send cached poolamountOut(the area under the curve) data for accounting purposes\\n                poolamountIn = cached_poolamountOut; \\n            }\\n\\n            // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \\n            // s_tradeToken.mint(msg.sender, uint256(amountIn)); \\n        }\\n\\n    }\\n\\n    /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \\n    function takerClose(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        // Sell down\\n        if(isLong){\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender,\\n                false, \\n                amountIn, //this should be trade tokens\\n                priceLimit, \\n                data\\n            ); \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \\n        }\\n\\n        else{            \\n            // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountIn = poolamountIn; \\n\\n            // collateral used to buy short \\n            poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\\n            else {\\n                burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \\n                poolamountOut = cached_poolamountIn; \\n            }\\n\\n            // s_tradeToken.burn(msg.sender, poolamountOut); \\n            // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\\n        }\\n    }\\n\\n    /// @notice provides oneTimeliquidity in the range (point,point+1)\\n    /// @param amount is in base if long, trade if in short  \\n    function makerOpen(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong,\\n        address recipient\\n        )external  returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // escrowAmount is base \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient,\\n                point, \\n                uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \\n                false\\n                ); \\n            BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \\n        }\\n\\n        // need to set limit for sells, but claiming process is different then regular sells \\n        else{\\n            // escrowAmount is trade \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \\n                true\\n                ); \\n\\n            // escrow amount is (maxPrice - avgPrice) * quantity \\n            uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) //positive since adding asks, not subtracting \\n                    ); \\n            BaseToken.transferFrom(recipient, address(this), escrowCollateral); \\n            toEscrowAmount = escrowCollateral; \\n        }\\n\\n    }\\n\\n    function makerClaimOpen(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \\n\\n            // user already escrowed funds, so need to send him tradeTokens \\n            TradeToken.mint(recipient, claimedAmount);          \\n        }\\n\\n        else{           \\n            s_tradeToken.mint(recipient, \\n                tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    getLiq(msg.sender, point, true)\\n                    )\\n                ); \\n\\n            // open short is filled sells, check if sells are filled. If it is,\\n            // claimedAmount of basetokens should already be in this contract \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n        }\\n\\n    }\\n    /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\\n    /// with shortTrade quantity )\\n    function makerClose(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // close long is putting up trades for sells, \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point, \\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                true\\n                ); \\n            //maybe burn it when claiming, and just escrow? \\n            TradeToken.burn(recipient, toEscrowAmount); \\n        }\\n\\n        else{\\n            // Place limit orders for buys \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                false\\n                ); \\n\\n            // burn s_tradeTokens, \\n            s_tradeToken.burn(recipient, amount); \\n\\n        }\\n    }\\n\\n    function makerClaimClose(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        ) external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            // Sell is filled, so need to transfer back base \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n            BaseToken.transfer(recipient, claimedAmount); \\n        }\\n        else{\\n            uint128 liq = getLiq(recipient, point, false); \\n\\n            // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\\n            claimedAmount = claimFilledOrder(recipient, point, false);\\n            claimedAmount = claimedAmount.mulWadDown(maxPrice) \\n                            - baseGivenLiquidity(\\n                            pointToPrice(point+1), \\n                            pointToPrice(point), \\n                            liq); \\n            BaseToken.transfer(recipient, claimedAmount);\\n        }\\n    }    \\n\\n    function makerPartiallyClaim(\\n        uint16 point, \\n        bool isLong,\\n        bool open, \\n        address recipient\\n        ) external returns(uint256 baseAmount, uint256 tradeAmount){\\n   \\n        if(open){\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\\n        }\\n        else{\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\\n        }\\n        \\n        BaseToken.transfer(recipient, baseAmount);\\n        TradeToken.mint(recipient, tradeAmount); \\n    }\\n\\n    /// @notice amount is in base if long, trade if short \\n    function makerReduceOpen(\\n        uint16 point, \\n        uint256 amount, \\n        bool isLong, \\n        address recipient\\n        ) external{\\n    \\n        if(isLong){\\n            uint256 returned_amount =reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenBase(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point),\\n                    amount\\n                    ).toUint128(), \\n                false\\n                ); \\n            // need to send base back \\n            BaseToken.transfer(recipient, returned_amount); \\n        }\\n        else {\\n            uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \\n            // Reduce asks \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liq, \\n                true\\n                ); \\n\\n            // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \\n            BaseToken.transfer(recipient, \\n                amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\\n        }\\n    }\\n\\n    /// @notice amount is in trade if long, ALSO trade if short \\n    function makerReduceClose(      \\n        uint16 point, \\n        uint256 amount, \\n        bool isLong,\\n        address recipient\\n        ) external{\\n\\n        if(isLong){\\n            uint256 returned_amount = reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                true\\n                ); \\n            // need to send trade back \\n            TradeToken.mint(recipient, returned_amount); \\n        }\\n\\n        else{\\n            // reduce limit bids \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                false\\n            ); \\n             \\n            s_tradeToken.mint(recipient, amount); \\n        }\\n    }\\n\\n    function provideLiquidity(\\n        uint16 pointLower,\\n        uint16 pointUpper,\\n        uint128 amount, \\n        bytes calldata data \\n        ) external {\\n\\n        (uint256 amount0, uint256 amount1) = provide(\\n            msg.sender, \\n            pointLower, \\n            pointUpper, \\n            amount, \\n            data \\n        ); \\n        BaseToken.transferFrom(msg.sender, address(this), amount0); \\n        // TradeToken.transferFrom(msg.sender, address(this), amount1);\\n        TradeToken.burn(msg.sender, amount1);\\n    }\\n\\n    function withdrawLiquidity(\\n        uint16 pointLower,\\n        uint16 pointUpper,\\n        uint128 amount, \\n        bytes calldata data \\n        )external{\\n\\n        (uint256 amountBase, uint256 amountTrade) = remove(\\n            msg.sender, \\n            pointLower, \\n            pointUpper, \\n            amount\\n        ); \\n      \\n        collect(\\n            msg.sender, \\n            pointLower,\\n            pointUpper,\\n            type(uint128).max,\\n            type(uint128).max\\n        ); \\n\\n        BaseToken.transfer(msg.sender,  amountBase); \\n        TradeToken.mint(msg.sender, amountTrade); \\n    }\\n    function getTraderPosition()external view{}\\n\\n    //TODO fees, skipping uninit for gas, below functions\\n    // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \\n    // trader fills, and immediately submit a ask much higher/lower\\n    // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\\n\\n}\\n\\ninterface iTradeCallBack{\\n    function tradeCallBack(\\n        uint256 amount0,\\n bytes calldata data    ) external;\\n} \\n\",\"keccak256\":\"0x34fc6c2553c937d54825817e73b13e66583059001d9ed4bcbd1ad4ac5b953324\"},\"contracts/bonds/libraries.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMath {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint256(y)) == y);\\n    // }\\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint160(y)) == y);\\n    // }\\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\\n\\ncontract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n    function mint(address to, uint256 amount) public {\\n      _mint(to, amount); \\n    }\\n    function burn(address to, uint256 amount) public {\\n      _burn(to, amount); \\n    }\\n}\",\"keccak256\":\"0x6f4b41b0a3a677144ec92ae040f756a7af61ffe54f497f92d7f20a729b3cb091\"},\"contracts/bonds/synthetic.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport { LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {BoundedDerivativesPool} from \\\"./boundedDerivatives.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\ncontract ZCBFactory{\\n    function newBond(\\n        string memory name, \\n        string memory description \\n        ) public returns(address) {\\n        ERC20 bondToken = new ERC20(name,description, 18);\\n        return address(bondToken); \\n    }\\n\\n}\\ncontract SyntheticZCBPoolFactory{\\n    address public immutable controller;\\n    address public immutable zcbFactory; \\n    constructor(address _controller, address _zcbFactory){\\n        controller = _controller; \\n        zcbFactory = _zcbFactory; \\n    }\\n\\n\\n    /// @notice param base is the collateral used in pool \\n    function newPool(\\n        address base, \\n        address entry\\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\\n        longZCB = ZCBFactory(zcbFactory).newBond(\\\"longZCB\\\", \\\"long\\\");\\n        shortZCB = ZCBFactory(zcbFactory).newBond(\\\"shortZCB\\\", \\\"short\\\");\\n\\n        pool = new SyntheticZCBPool(\\n            base, longZCB, shortZCB, entry, controller\\n        ); \\n    }\\n}\\n\\ncontract SyntheticZCBPool is BoundedDerivativesPool{\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 public a_initial;\\n    uint256 public b_initial; // b without discount cap \\n    uint256 public b;\\n    uint256 public discount_cap; \\n    uint256 public discountedReserves; \\n\\n    address public immutable controller; \\n    uint256 public constant precision = 1e18; \\n    constructor(address base, \\n        address trade, \\n        address s_trade, \\n        address _entry, \\n        address _controller\\n        )BoundedDerivativesPool(base,trade,s_trade, false){\\n        entry = _entry; \\n        controller = _controller; \\n        }\\n\\n    /// @notice calculate and store initial curve params that takes into account\\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \\n    /// @param sigma is the proportion of P that is going to be bought at a discount  \\n    function calculateInitCurveParams(\\n        uint256 P, \\n        uint256 I, \\n        uint256 sigma) external {\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        b_initial = (2*P).divWadDown(P+I) - precision; \\n        a_initial = (precision-b_initial).divWadDown(P+I); \\n\\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\\n        (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\\n\\n        // Set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a_initial))); \\n        setPriceAndPoint(b); \\n    }\\n\\n    /// @notice calculates initparams for pool based instruments \\n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\\n    function calculateInitCurveParamsPool(\\n        uint256 saleAmount, \\n        uint256 initPrice, \\n        uint256 endPrice, \\n        uint256 sigma\\n        ) external returns(uint256 managementFee){\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n\\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \\n        uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \\n        \\n        //Set discount cap as saleAmount * sigma \\n        (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \\n        b = initPrice; \\n\\n        // How much total discounts are validators and managers getting\\n        managementFee = discount_cap.mulWadDown(endPrice) \\n            - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \\n\\n        // set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a))); \\n        setPriceAndPoint(b); \\n        setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \\n        setModifyLiqPoint(priceToPoint(endPrice)); \\n    }\\n\\n    /// @notice computes area between the curve and max price for given storage parameters\\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\\n        (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \\n        return amountDelta.mulWadDown(maxPrice) - amount; \\n    }\\n\\n    /// @notice mints new zcbs \\n    function trustedDiscountedMint(\\n        address receiver, \\n        uint256 amount \\n        ) external{\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        TradeToken.mint(receiver, amount);\\n        discountedReserves += amount;  \\n    }\\n\\n\\n    function trustedBurn(\\n        address trader, \\n        uint256 amount, \\n        bool long\\n        ) external {\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        if (long) TradeToken.burn(trader, amount); \\n        else s_tradeToken.burn(trader, amount);\\n    }\\n\\n    function flush(address flushTo, uint256 amount) external {\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \\n        else BaseToken.transfer(flushTo, amount); \\n    }\\n\\n    /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \\n    /// by anyone \\n    function resetLiq() external{\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        setLiquidity(0); \\n        amortizeLiq(); \\n    }\\n\\n    function cBal() external view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n}\\n\",\"keccak256\":\"0xb4b30b20a2cc136b02baf71b6bed9275471040f6e6f7cab2fd11b1802b4af43f\"},\"contracts/chainlink/VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\",\"keccak256\":\"0xd4697556c95e0f2e5055eea0b07b4d476887052d95dbf838b3cf7c32436c71d1\",\"license\":\"MIT\"},\"contracts/chainlink/VRFCoordinatorV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\",\"keccak256\":\"0xadc1f1babaa7202145a22d82c85176cbe7f1fae993f2c11dabdf6058aebea6b2\",\"license\":\"MIT\"},\"contracts/protocol/controller.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\n// import {ReputationNFT} from \\\"./reputationtoken.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {Strings} from \\\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VaultFactory} from \\\"./factories.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\"; \\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {SyntheticZCBPoolFactory, SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\"; \\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ReputationManager} from \\\"./reputationmanager.sol\\\";\\n\\n\\ncontract Controller {\\n  using SafeMath for uint256;\\n  using FixedPointMathLib for uint256;\\n  using SafeTransferLib for ERC20;\\n\\n  struct MarketData {\\n      address instrument_address;\\n      address utilizer;\\n  }\\n\\n  struct ApprovalData{\\n    uint256 approved_principal; \\n    uint256 approved_yield; \\n  }\\n\\n  event MarketInitiated(uint256 marketId, address recipient);\\n\\n  mapping(uint256=>ApprovalData) approvalDatas;\\n\\n  function getApprovalData(uint256 marketId) public view returns (ApprovalData memory) {\\n    approvalDatas[marketId];\\n  }\\n\\n  mapping(address => bool) public  verified;\\n  mapping(uint256 => MarketData) public market_data; // id => recipient\\n  mapping(address=> uint256) public ad_to_id; //utilizer address to marketId\\n  mapping(uint256=> Vault) public vaults; // vault id to Vault contract\\n  mapping(uint256=> uint256) public id_parent; //marketId-> vaultId \\n  mapping(uint256=>uint256[]) public vault_to_marketIds;\\n\\n  address creator_address;\\n\\n  // IInterep interep;\\n  // TrustedMarketFactoryV3 marketFactory;\\n  MarketManager marketManager;\\n  // ReputationNFT repNFT; \\n  VaultFactory vaultFactory; \\n  SyntheticZCBPoolFactory poolFactory; \\n  ReputationManager reputationManager;\\n\\n  uint256 constant TWITTER_UNRATED_GROUP_ID = 16106950158033643226105886729341667676405340206102109927577753383156646348711;\\n  bytes32 constant private signal = bytes32(\\\"twitter-unrated\\\");\\n  uint256 constant MIN_DURATION = 1 days;\\n\\n  /* ========== MODIFIERS ========== */\\n  modifier onlyValidator(uint256 marketId) {\\n      require(isValidator(marketId, msg.sender)|| msg.sender == creator_address, \\\"!Val\\\");\\n      _;\\n  }\\n\\n  modifier onlyManager() {\\n      require(msg.sender == address(marketManager) || msg.sender == creator_address, \\\"!manager\\\");\\n      _;\\n  }\\n\\n  constructor (\\n      address _creator_address,\\n      address _interep_address //TODO\\n  ) {\\n      creator_address = _creator_address;\\n  }\\n\\n  /*----Setup Functions----*/\\n\\n  function setMarketManager(address _marketManager) public onlyManager {\\n    require(_marketManager != address(0));\\n    marketManager = MarketManager(_marketManager);\\n  }\\n\\n  function setReputationManager(address _reputationManager) public onlyManager {\\n    reputationManager = ReputationManager(_reputationManager);\\n  }\\n\\n  function setVaultFactory(address _vaultFactory) public onlyManager {\\n    vaultFactory = VaultFactory(_vaultFactory); \\n  }\\n\\n  function setPoolFactory(address _poolFactory) public onlyManager{\\n    poolFactory = SyntheticZCBPoolFactory(_poolFactory); \\n  }\\n\\n  // function verifyAddress(\\n  //     uint256 nullifier_hash, \\n  //     uint256 external_nullifier,\\n  //     uint256[8] calldata proof\\n  // ) external  {\\n  //     require(!verified[msg.sender], \\\"address already verified\\\");\\n  //     interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\\n  //     verified[msg.sender] = true;\\n  // }\\n\\n  function testVerifyAddress() external {\\n    verified[msg.sender] = true;\\n  }\\n  /// @notice called only when redeeming, transfer funds from vault \\n  function redeem_transfer(\\n    uint256 amount, \\n    address to, \\n    uint256 marketId) \\n  external onlyManager{\\n    vaults[id_parent[marketId]].trusted_transfer(amount,to); \\n  }\\n  \\n  /// @notice creates vault\\n  /// @param underlying: underlying asset for vault\\n  /// @param _onlyVerified: only verified users can mint shares\\n  /// @param _r: minimum reputation score to mint shares\\n  /// @param _asset_limit: max number of shares for a single address\\n  /// @param _total_asset_limit: max number of shares for entire vault\\n  /// @param default_params: default params for markets created by vault\\n  function createVault(\\n    address underlying,\\n    bool _onlyVerified, \\n    uint256 _r, \\n    uint256 _asset_limit, \\n    uint256 _total_asset_limit, \\n    MarketManager.MarketParameters memory default_params \\n  ) public {\\n    (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\\n     underlying, \\n     address(this),\\n     _onlyVerified, \\n     _r, \\n     _asset_limit,\\n     _total_asset_limit,\\n     default_params\\n    );\\n\\n    vaults[vaultId] = newVault;\\n  }\\n\\n  /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\\n  /// @dev Instrument should already be deployed \\n  /// @param recipient: utilizer for the associated instrument\\n  /// @param instrumentData: instrument arguments\\n  /// @param vaultId: vault identifier\\n  function initiateMarket(\\n    address recipient,\\n    Vault.InstrumentData memory instrumentData, \\n    uint256 vaultId\\n  ) external  {\\n    require(recipient != address(0), \\\"address0\\\"); \\n    require(instrumentData.instrument_address != address(0), \\\"address0\\\");\\n    require(address(vaults[vaultId]) != address(0), \\\"address0\\\");\\n\\n    Vault vault = vaults[vaultId]; \\n    uint256 marketId = marketManager.marketCount();\\n    id_parent[marketId] = vaultId;\\n    vault_to_marketIds[vaultId].push(marketId);\\n    market_data[marketId] = MarketData(instrumentData.instrument_address, recipient);\\n    marketManager.setParameters(vault.get_vault_params(), vault.utilizationRate(), marketId); //TODO non-default \\n\\n    // Create new pool and bonds and store initial price and liquidity for the pool\\n    (address longZCB, address shortZCB, SyntheticZCBPool pool) \\n              = poolFactory.newPool(address(vaults[vaultId].UNDERLYING()), address(marketManager)); \\n\\n    if (instrumentData.isPool){\\n      instrumentData.poolData.managementFee = pool.calculateInitCurveParamsPool(\\n        instrumentData.poolData.saleAmount, instrumentData.poolData.initPrice, \\n        instrumentData.poolData.inceptionPrice, marketManager.getParameters(marketId).sigma); \\n\\n      marketManager.newMarket(marketId, pool, longZCB, shortZCB, instrumentData.description, true); \\n\\n      // set validators\\n      _validatorSetup(marketId, instrumentData.poolData.saleAmount, instrumentData.isPool);\\n    }\\n    else{\\n      pool.calculateInitCurveParams(instrumentData.principal,\\n          instrumentData.expectedYield, marketManager.getParameters(marketId).sigma); \\n\\n      marketManager.newMarket(marketId, pool, longZCB, shortZCB, instrumentData.description, false);\\n      // set validators\\n      _validatorSetup(marketId, instrumentData.principal, instrumentData.isPool);\\n    }\\n\\n    // add vault proposal \\n    instrumentData.marketId = marketId;\\n    vault.addProposal(instrumentData);\\n\\n    emit MarketInitiated(marketId, recipient);\\n    ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\\n  }\\n\\n  /// @notice Resolve function 1\\n  /// @dev Prepare market/instrument for closing, called separately before resolveMarket\\n  /// this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest\\n  /// or, in the event of a default, by validators who deem the principal recouperation is finished\\n  /// and need to collect remaining funds by redeeming ZCB\\n  function beforeResolve(uint256 marketId) external \\n  //onlyValidator(marketId) \\n  {\\n    (bool duringMarketAssessment, , , bool alive ,,) = marketManager.restriction_data(marketId); \\n    require(!duringMarketAssessment && alive, \\\"market conditions not met\\\");\\n    require(resolveCondition(marketId), \\\"not enough validators have voted to resolve\\\");\\n    vaults[id_parent[marketId]].beforeResolve(marketId);\\n  }\\n \\n  /// Resolve function 2\\n  /// @notice main function called at maturity OR premature resolve of instrument(from early default)  \\n  /// @dev validators call this function from market manager\\n  /// any funds left for the instrument, irrespective of whether it is in profit or inloss. \\n  function resolveMarket(\\n    uint256 marketId\\n    ) external onlyValidator(marketId) {\\n    (bool atLoss, uint256 extra_gain, uint256 principal_loss, bool premature) \\n          = vaults[id_parent[marketId]].resolveInstrument(marketId);\\n\\n    updateRedemptionPrice(marketId, atLoss, extra_gain, principal_loss, premature);\\n    _updateValidatorStake(marketId, approvalDatas[marketId].approved_principal, principal_loss);\\n    cleanUpDust(marketId);\\n  }\\n\\n  /// @dev Redemption price, as calculated (only once) at maturity,\\n  /// depends on total_repayed/(principal + predetermined yield)\\n  /// If total_repayed = 0, redemption price is 0\\n  /// @param atLoss: defines circumstances where expected returns are higher than actual\\n  /// @param loss: facevalue - returned amount => non-negative always?\\n  /// @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\\n  function updateRedemptionPrice(\\n    uint256 marketId,\\n    bool atLoss, \\n    uint256 extra_gain, \\n    uint256 loss, \\n    bool premature\\n  ) internal   {  \\n    if (atLoss) assert(extra_gain == 0); \\n\\n    uint256 total_supply = marketManager.getZCB(marketId).totalSupply(); \\n    uint256 total_shorts = (extra_gain >0) ?  marketManager.getShortZCB(marketId).totalSupply() :0; \\n    uint256 redemption_price; \\n    if(!atLoss)\\n      redemption_price = config.WAD + extra_gain.divWadDown(total_supply + total_shorts); \\n    \\n    else {\\n      if (config.WAD <= loss.divWadDown(total_supply)){\\n        redemption_price = 0; \\n      }\\n      else {\\n        redemption_price = config.WAD - loss.divWadDown(total_supply);\\n      }\\n    }\\n\\n    marketManager.deactivateMarket(marketId, atLoss, !premature, redemption_price); \\n\\n    // TODO edgecase redemption price calculations  \\n  }\\n\\n  uint256 public constant riskTransferPenalty = 1e17; \\n  /// @notice deduce fees for non vault stakers, should go down as maturity time approach 0 \\n  function deduct_selling_fee(uint256 marketId ) public view returns(uint256){\\n    // Linearly decreasing fee \\n    uint256 normalizedTime = (getVault(marketId).fetchInstrumentData(marketId).maturityDate- block.timestamp) \\n     * config.WAD / getVault(marketId).fetchInstrumentData(marketId).duration; \\n    return normalizedTime.mulWadDown( riskTransferPenalty); \\n  }\\n\\n  /// @notice When market resolves, should collect remaining liquidity and/or dust from  \\n  /// the pool and send them back to the vault\\n  /// @dev should be called before redeem_transfer is allowed \\n  function cleanUpDust(uint256 marketId) internal {\\n    marketManager.getPool(marketId).flush(getVaultAd(marketId), type(uint256).max); \\n  }\\n\\n  /// @notice when market is resolved(maturity/early default), calculates score\\n  /// and update each assessment phase trader's reputation, called by individual traders when redeeming \\n  function updateReputation (\\n    uint256 marketId, \\n    address trader, \\n    bool increment) \\n  external onlyManager {\\n    uint256 implied_probs = marketManager.assessment_probs(marketId, trader);\\n    // int256 scoreToUpdate = increment ? int256(implied_probs.mulDivDown(implied_probs, config.WAD)) //experiment \\n    //                                  : -int256(implied_probs.mulDivDown(implied_probs, config.WAD));\\n    uint256 change = implied_probs.mulDivDown(implied_probs, config.WAD);\\n    \\n    if (increment) {\\n      reputationManager.incrementScore(trader, change);\\n    } else {\\n      reputationManager.decrementScore(trader, change);\\n    }\\n  }\\n\\n  /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\\n  /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc. \\n  /// After, the resolveMarket function should be called in a new block  \\n  /// @dev withdraws all balance from the instrument. \\n  /// If assets in instrument is not in underlying, need all balances to be divested to underlying \\n  /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\\n  /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\\n  function forceCloseInstrument(uint256 marketId, bool emergency) external returns(bool){\\n    Vault vault = vaults[id_parent[marketId]]; \\n\\n    // Prepare for close \\n    vault.closeInstrument(marketId); \\n\\n    // Harvests/records all profit & losses\\n    vault.beforeResolve(marketId); \\n    return true;\\n  }\\n\\n  /// @notice returns true if amount bought is greater than the insurance threshold\\n  function marketCondition(uint256 marketId) public view returns(bool){\\n    ( , , , , , ,bool isPool )= marketManager.markets(marketId); \\n    if (isPool){\\n      return (marketManager.loggedCollaterals(marketId) >=\\n        getVault(marketId).fetchInstrumentData(marketId).poolData.saleAmount); \\n    }\\n    else{\\n      uint256 principal = getVault(marketId).fetchInstrumentData(marketId).principal;\\n      return (marketManager.loggedCollaterals(marketId) >= principal.mulWadDown(marketManager.getParameters(marketId).alpha));\\n    }\\n  }\\n\\n\\n  /// @notice called by the validator from validatorApprove when market conditions are met\\n  /// need to move the collateral in the wCollateral to \\n  function approveMarket(\\n    uint256 marketId\\n  ) internal {\\n    Vault vault = vaults[id_parent[marketId]]; \\n    SyntheticZCBPool pool = marketManager.getPool(marketId); \\n    \\n    require(marketManager.getCurrentMarketPhase(marketId) == 3,\\\"!marketCondition\\\");\\n    require(vault.instrumentApprovalCondition(marketId), \\\"!instrumentCondition\\\");\\n\\n    ( , , , , , ,bool isPool )= marketManager.markets(marketId); \\n    uint256 managerCollateral = marketManager.loggedCollaterals(marketId); \\n\\n    if (isPool) {\\n      poolApproval(marketId, marketManager.getZCB( marketId).totalSupply(), \\n        vault.fetchInstrumentData( marketId).poolData); \\n    }\\n\\n    else {\\n      if (vault.getInstrumentType(marketId) == 0) creditApproval(marketId, pool); \\n\\n      else generalApproval(marketId); \\n    }\\n    // pull from pool to vault, which will be used to fund the instrument\\n    pool.flush(address(vault), managerCollateral); \\n\\n    // Trust and deposit to the instrument contract\\n    vault.trustInstrument(marketId, approvalDatas[marketId], isPool);\\n\\n    // Since funds are transfered from pool to vault, set default liquidity in pool to 0 \\n    pool.resetLiq(); \\n  }\\n\\n  function poolApproval(uint256 marketId, uint256 juniorSupply, Vault.PoolData memory data ) internal{\\n    require(data.leverageFactor > 0, \\\"0 LEV_FACTOR\\\"); \\n    approvalDatas[marketId] = ApprovalData(juniorSupply\\n      .mulWadDown(config.WAD + data.leverageFactor).mulWadDown(data.inceptionPrice), 0 ); \\n  }\\n\\n  /// @notice receives necessary market information. Only applicable for creditlines \\n  /// required for market approval such as max principal, quoted interest rate\\n  function creditApproval(uint256 marketId, SyntheticZCBPool pool) internal{\\n    (uint256 proposed_principal, uint256 proposed_yield) \\n          = vaults[id_parent[marketId]].viewPrincipalAndYield(marketId); \\n\\n    // get max_principal which is (s+1) * total long bought for creditline, or just be\\n    // proposed principal for other instruments \\n    uint256 max_principal = min((marketManager.getParameters(marketId).s + config.WAD)\\n                            .mulWadDown(marketManager.loggedCollaterals(marketId)),\\n                            proposed_principal ); \\n\\n    // Required notional yield amount denominated in underlying  given credit determined by managers\\n    uint256 quoted_interest = min(pool.areaBetweenCurveAndMax(max_principal), proposed_yield ); \\n\\n    approvalDatas[marketId] = ApprovalData(max_principal, quoted_interest); \\n  }\\n\\n  function generalApproval(uint256 marketId) internal {\\n    (uint256 proposed_principal, uint256 proposed_yield) = vaults[id_parent[marketId]].viewPrincipalAndYield(marketId); \\n    approvalDatas[marketId] = ApprovalData(proposed_principal, proposed_yield); \\n  }\\n\\n  /**\\n   @dev called by validator denial of market.\\n   */\\n  function denyMarket(\\n      uint256 marketId\\n  ) external  onlyValidator(marketId) {\\n    vaults[id_parent[marketId]].denyInstrument(marketId);\\n    cleanUpDust(marketId);\\n    marketManager.denyMarket(marketId);\\n  }\\n\\n\\n  /*----Validator Logic----*/\\n  struct ValidatorData {\\n    mapping(address => uint256) sales; // amount of zcb bought per validator\\n    mapping(address => bool) staked; // true if address has staked vt (approved)\\n    mapping(address => bool) resolved; // true if address has voted to resolve the market\\n    address[] validators;\\n    uint256 val_cap;// total zcb validators can buy at a discount\\n    uint256 avg_price; //price the validators can buy zcb at a discount \\n    bool requested; // true if already requested random numbers from array.\\n    uint256 totalSales; // total amount of zcb bought;\\n    uint256 totalStaked; // total amount of vault token staked.\\n    uint256 numApproved;\\n    uint256 initialStake; // amount staked\\n    uint256 finalStake; // amount of stake recoverable post resolve\\n    uint256 numResolved; // number of validators calling resolve on early resolution.\\n  }\\n\\n  mapping(uint256 => uint256) requestToMarketId;\\n  mapping(uint256 => ValidatorData) public validator_data;\\n\\n    /// @notice sets the validator cap + valdiator amount \\n  /// param prinicipal is saleAmount for pool based instruments \\n  /// @dev called by controller to setup the validator scheme\\n  function _validatorSetup(\\n    uint256 marketId,\\n    uint256 principal,\\n    bool isPool\\n  ) internal {\\n    require(principal != 0, \\\"0 principal\\\");\\n    _getValidators(marketId);\\n    _setValidatorCap(marketId, principal, isPool);\\n    _setValidatorStake(marketId, principal);\\n  }\\n\\n  function getValidatorPrice(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].avg_price;\\n  }\\n\\n  function getValidatorCap(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].val_cap;\\n  }  \\n\\n  function viewValidators(uint256 marketId) view public returns (address[] memory) {\\n    return validator_data[marketId].validators;\\n  }\\n\\n  function getNumApproved(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].numApproved;\\n  }\\n\\n  function getNumResolved(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].numResolved;\\n  }\\n\\n  function getTotalStaked(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].totalStaked;\\n  }\\n\\n  function getTotalValidatorSales(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].totalSales;\\n  }\\n\\n  function getInitialStake(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].initialStake;\\n  }\\n\\n  function getFinalStake(uint256 marketId) view public returns (uint256) {\\n    return validator_data[marketId].finalStake;\\n  }\\n\\n  /**\\n   @notice randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\\n   @dev for now called on market initialization\\n   */\\n  function _getValidators(uint256 marketId) public {\\n    // retrieve traders that meet requirement.\\n    // address instrument = market_data[marketId].instrument_address;\\n    address utilizer = market_data[marketId].utilizer;\\n    (uint256 N,,,,,uint256 r,,) = marketManager.parameters(marketId);\\n    address[] memory selected = reputationManager.filterTraders(r, utilizer);\\n\\n    // if there are not enough traders, set validators to all selected traders.\\n    if (selected.length <= N) {\\n      validator_data[marketId].validators = selected;\\n      if (selected.length < N) marketManager.setN(marketId, selected.length);\\n      return;\\n    }\\n\\n    validator_data[marketId].requested = true;\\n\\n    uint256 _requestId = 1;\\n    // uint256 _requestId = COORDINATOR.requestRandomWords(\\n    //   keyHash,\\n    //   subscriptionId,\\n    //   requestConfirmations,\\n    //   callbackGasLimit,\\n    //   uint32(parameters[marketId].N)\\n    // );\\n\\n    requestToMarketId[_requestId] = marketId;\\n  }\\n\\n    /**\\n   @notice chainlink callback function, sets validators.\\n   @dev TODO => can be called by anyone?\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \\n  public //internal  \\n  //override \\n  {\\n    uint256 marketId = requestToMarketId[requestId];\\n    (uint256 N,,,,,uint256 r,,) = marketManager.parameters(marketId);\\n    \\n    assert(randomWords.length == N);\\n\\n    // address instrument = market_data[marketId].instrument_address;\\n    address utilizer = market_data[marketId].utilizer;\\n\\n    address[] memory temp = reputationManager.filterTraders(r, utilizer);\\n    uint256 length = temp.length;\\n    \\n    // get validators\\n    for (uint8 i=0; i<N; i++) {\\n      uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\\n      validator_data[marketId].validators.push(temp[j]);\\n      temp[j] = temp[length - 1];\\n      length--;\\n    }\\n  }\\n\\n  function _weightedRetrieve(address[] memory group, uint256 length, uint256 randomWord) view internal returns (uint256) {\\n    uint256 sum_weights;\\n\\n    for (uint8 i=0; i<length; i++) {\\n      sum_weights += getTraderScore(group[i]);//repToken.getReputationScore(group[i]);\\n    }\\n\\n    uint256 tmp = randomWord % sum_weights;\\n\\n    for (uint8 i=0; i<length; i++) {\\n      uint256 wt = getTraderScore(group[i]);\\n      if (tmp < wt) {\\n        return i;\\n      }\\n      unchecked {\\n        tmp -= wt;\\n      }\\n      \\n    }\\n  }\\n\\n    /// @notice allows validators to buy at a discount + automatically stake a percentage of the principal\\n  /// They can only buy a fixed amount of ZCB, usually a at lot larger amount \\n  /// @dev get val_cap, the total amount of zcb for sale and each validators should buy \\n  /// val_cap/num validators zcb \\n  /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly \\n  /// correlated instruments triggers controller.approveMarket\\n  function validatorApprove(\\n    uint256 marketId\\n  ) external returns(uint256) {\\n    require(isValidator(marketId, msg.sender), \\\"!Val\\\");\\n    require(marketCondition(marketId), \\\"!condition\\\");\\n\\n    ValidatorData storage valdata = validator_data[marketId]; \\n    require(!valdata.staked[msg.sender], \\\"!staked\\\");\\n\\n    // staking logic, TODO optional since will throw error on transfer.\\n   // require(ERC20(getVaultAd(marketId)).balanceOf(msg.sender) >= valdata.initialStake, \\\"not enough tokens to stake\\\");\\n    \\n    // staked vault tokens go to controller\\n    ERC20(getVaultAd(marketId)).safeTransferFrom(msg.sender, address(this), valdata.initialStake);\\n\\n    valdata.totalStaked += valdata.initialStake;\\n    valdata.staked[msg.sender] = true;\\n\\n    (uint256 N,,,,,,,) = marketManager.parameters(marketId);\\n    uint256 zcb_for_sale = valdata.val_cap/N; \\n    uint256 collateral_required = zcb_for_sale.mulWadDown(valdata.avg_price); \\n\\n    require(valdata.sales[msg.sender] <= zcb_for_sale, \\\"approved\\\");\\n\\n    valdata.sales[msg.sender] += zcb_for_sale;\\n    valdata.totalSales += (zcb_for_sale +1);  //since division rounds down ??\\n    valdata.numApproved += 1;\\n\\n    // marketManager actions on validatorApprove, transfers collateral to marketManager.\\n    marketManager.validatorApprove(marketId, collateral_required, zcb_for_sale, msg.sender);\\n\\n    // Last validator pays more gas, is fair because earlier validators are more uncertain \\n    if (approvalCondition(marketId)) {\\n      approveMarket(marketId);\\n      marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\\n    }\\n\\n    return collateral_required;\\n  }\\n\\n  /**\\n   @notice conditions for approval => validator zcb stake fulfilled + validators have all approved\\n   */\\n  function approvalCondition(uint256 marketId ) public view returns(bool){\\n    return (validator_data[marketId].totalSales >= validator_data[marketId].val_cap \\n    && validator_data[marketId].validators.length == validator_data[marketId].numApproved);\\n  }\\n\\n  /**\\n   @notice returns true if user is validator for corresponding market\\n   */\\n  function isValidator(uint256 marketId, address user) view public returns(bool){\\n    address[] storage _validators = validator_data[marketId].validators;\\n    for (uint i = 0; i < _validators.length; i++) {\\n      if (_validators[i] == user) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   @notice condition for resolving market, met when all the validators chosen for the market\\n   have voted to resolve.\\n   */\\n  function resolveCondition(\\n    uint256 marketId\\n  ) public view returns (bool) {\\n    return (validator_data[marketId].numResolved == validator_data[marketId].validators.length);\\n  }\\n\\n  /**\\n   @notice updates the validator stake, burned in proportion to loss.\\n   principal and principal loss are in the underlying asset of the vault => must be converted to vault shares.\\n   @dev called by resolveMarket\\n   */\\n  function _updateValidatorStake (\\n    uint256 marketId, \\n    uint256 principal, \\n    uint256 principal_loss\\n  ) \\n    internal\\n  {\\n    if (principal_loss == 0) {\\n      validator_data[marketId].finalStake = validator_data[marketId].initialStake;\\n      return;\\n    }\\n\\n    ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n    uint256 p_shares = vault.convertToShares(principal);\\n    uint256 p_loss_shares = vault.convertToShares(principal_loss);\\n\\n    uint256 totalStaked = validator_data[marketId].totalStaked;\\n    uint256 newTotal = totalStaked/2 + (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(totalStaked/2);\\n\\n    ERC4626(getVaultAd(marketId)).burn(totalStaked - newTotal);\\n    validator_data[marketId].totalStaked = newTotal;\\n\\n    validator_data[marketId].finalStake = newTotal/validator_data[marketId].validators.length;\\n  }\\n\\n    /**\\n   @notice called by validators to approve resolving the market, after approval.\\n   */\\n  function validatorResolve(\\n    uint256 marketId\\n  ) external {\\n    require(isValidator(marketId, msg.sender), \\\"!val\\\");\\n    require(!validator_data[marketId].resolved[msg.sender], \\\"voted\\\");\\n\\n    validator_data[marketId].resolved[msg.sender] = true;\\n    validator_data[marketId].numResolved ++;\\n  }\\n\\n  /**\\n   @notice called by validators when the market is resolved or denied to retrieve their stake.\\n   */\\n  function unlockValidatorStake(uint256 marketId) external {\\n    require(isValidator(marketId, msg.sender), \\\"!validator\\\");\\n    require(validator_data[marketId].staked[msg.sender], \\\"!stake\\\");\\n    (bool duringMarketAssessment, , ,  ,,) = marketManager.restriction_data(marketId); \\n\\n    // market early denial, no loss.\\n    ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n    if (duringMarketAssessment) {\\n      ERC20(getVaultAd(marketId)).safeTransfer(msg.sender, validator_data[marketId].initialStake);\\n      validator_data[marketId].totalStaked -= validator_data[marketId].initialStake;\\n    } else { // market resolved.\\n      ERC20(getVaultAd(marketId)).safeTransfer(msg.sender, validator_data[marketId].finalStake);\\n      validator_data[marketId].totalStaked -= validator_data[marketId].finalStake;\\n    }\\n\\n    validator_data[marketId].staked[msg.sender] = false;\\n  }\\n\\n  /// @notice called when market initialized, calculates the average price and quantities of zcb\\n  /// validators will buy at a discount when approving\\n  /// valcap = sigma * princpal.\\n  function _setValidatorCap(\\n    uint256 marketId,\\n    uint256 principal,\\n    bool isPool //??\\n  ) internal {\\n    SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\\n    (,uint256 sigma,,,,,,) = marketManager.parameters(marketId);\\n    require(config.isInWad(sigma) && config.isInWad(principal), \\\"paramERR\\\");\\n    ValidatorData storage valdata = validator_data[marketId]; \\n\\n    uint256 valColCap = (sigma.mulWadDown(principal)); \\n\\n    // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved \\n    uint256 discount_cap = bondingPool.discount_cap();\\n    uint256 avgPrice = valColCap.divWadDown(discount_cap);\\n\\n    valdata.val_cap = discount_cap;\\n    valdata.avg_price = avgPrice; \\n  }\\n\\n  /**\\n   @notice sets the amount of vt staked by a single validator for a specific market\\n   @dev steak should be between 1-0 wad.\\n   */\\n  function _setValidatorStake(uint256 marketId, uint256 principal) internal {\\n    //get vault\\n    ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n    uint256 shares = vault.convertToShares(principal);\\n    (,,,,,,,uint256 steak) = marketManager.parameters(marketId);\\n    validator_data[marketId].initialStake = steak.mulWadDown(shares);\\n  }\\n\\n  function hasApproved(uint256 marketId, address validator) view public returns (bool) {\\n    return validator_data[marketId].staked[validator];\\n  }\\n\\n  /**\\n   @notice called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\\n   */\\n  function deniedValidator(uint256 marketId, address validator) onlyManager external returns (uint256 collateral_amount) {\\n    //??? is this correct\\n    collateral_amount = validator_data[marketId].sales[validator].mulWadDown(validator_data[marketId].avg_price);\\n    delete validator_data[marketId].sales[validator];\\n  }\\n\\n  function redeemValidator(uint256 marketId, address validator) onlyManager external {\\n    delete validator_data[marketId].sales[validator]; \\n  }\\n\\n  function getValidatorRequiredCollateral(uint256 marketId) public view returns(uint256){\\n    uint256 val_cap =  validator_data[marketId].val_cap;\\n    (uint256 N,,,,,,,) = marketManager.parameters(marketId);\\n    uint256 zcb_for_sale = val_cap/N; \\n    return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price); \\n  }\\n\\n  function getTraderScore(address trader) view public returns (uint256) {\\n    return reputationManager.trader_scores(trader);\\n  }\\n\\n  function isReputable(address trader, uint256 r) view public returns (bool) {\\n    return reputationManager.isReputable(trader, r);\\n  }\\n\\n  /// @notice calculates implied probability of the trader, used to\\n  /// update the reputation score by brier scoring mechanism \\n  /// @param budget of trader in collateral decimals \\n  function calcImpliedProbability(\\n    uint256 bondAmount, \\n    uint256 collateral_amount,\\n    uint256 budget\\n    ) public pure returns(uint256){\\n    uint256 avg_price = collateral_amount.divWadDown(bondAmount); \\n    uint256 b = avg_price.mulWadDown(config.WAD - avg_price);\\n    uint256 ratio = bondAmount.divWadDown(budget); \\n\\n    return ratio.mulWadDown(b)+ avg_price;\\n  }\\n\\n  function pullLeverage(uint256 marketId, uint256 amount) external onlyManager{\\n    getVault(marketId).trusted_transfer(amount, address(marketManager)); \\n  }\\n  function getTotalSupply(uint256 marketId) external view returns(uint256){\\n    return marketManager.getZCB(marketId).totalSupply(); \\n  }\\n\\n  function getMarketId(address recipient) public view returns(uint256){\\n    return ad_to_id[recipient];\\n  }\\n\\n  function getVault(uint256 marketId) public view returns(Vault){\\n    return vaults[id_parent[marketId]]; \\n  }\\n\\n  function getVaultAd(uint256 marketId) public view returns(address){\\n    return address(vaults[id_parent[marketId]]); \\n  }\\n\\n  function isVerified(address addr)  public view returns (bool) {\\n    return verified[addr];\\n  }\\n\\n  function getVaultfromId(uint256 vaultId) public view returns(address){\\n    return address(vaults[vaultId]); \\n  }\\n\\n  function marketId_to_vaultId(uint256 marketId) public view returns(uint256){\\n    return id_parent[marketId]; \\n  }\\n\\n  function marketIdToVaultId(uint256 marketId) public view returns(uint256){\\n    return id_parent[marketId]; \\n  }\\n  \\n  function getMarketIds(uint256 vaultId) public view returns (uint256[] memory) {\\n    return vault_to_marketIds[vaultId];\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n      return a <= b ? a : b;\\n  }\\n}\\n\\n\",\"keccak256\":\"0xcc9397a2598fb68a2e9979a284057892c1d52d0fe755085d2f8a32dea63587c1\"},\"contracts/protocol/factories.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\n\\n\\n/// @notice Anyone can create a vault. These can be users who  \\n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\\n/// c) a vault for any long-tailed assets \\n/// d) managers who wants leverage for yield opportunities on a specific asset \\n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \\n/// etc\\n/// They need to specify \\n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \\n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\\n/// 3. Vault underlying \\n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\\n\\ncontract VaultFactory{\\n\\n  address owner; \\n  mapping(address=>bool) private _isVault; \\n\\n  uint256 public numVaults; \\n  Controller controller; \\n\\n  constructor(address _controller){\\n    owner = msg.sender; \\n    controller = Controller(_controller);\\n  }\\n\\n  function isVault(address v) external view returns(bool){\\n    return _isVault[v]; \\n  }\\n\\n  modifier onlyController(){\\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"is not controller\\\"); \\n      _;\\n  }\\n\\n  /**\\n   @notice creates vault\\n   @param underlying: underlying asset for vault\\n   @param _controller: protocol controller\\n   @param _onlyVerified: only verified users can mint shares\\n   @param _r: minimum reputation score to mint shares\\n   @param _asset_limit: max number of shares for a single address\\n   @param _total_asset_limit: max number of shares for entire vault\\n   @param default_params: default params for markets created by vault\\n   */\\n  function newVault(\\n    address underlying, \\n    address _controller,\\n    bool _onlyVerified, \\n    uint256 _r, \\n    uint256 _asset_limit,\\n    uint256 _total_asset_limit,\\n    MarketManager.MarketParameters memory default_params\\n  ) external onlyController returns(Vault, uint256) {\\n    require(default_params.alpha >= 1e16, \\\"Alpha too small\\\"); \\n    \\n    Vault vault = new Vault(\\n      underlying,\\n       _controller, \\n       owner, \\n       //Params \\n       _onlyVerified,  _r, _asset_limit, _total_asset_limit,\\n       default_params \\n\\n       ); \\n    _isVault[address(vault)] = true; \\n    numVaults++; \\n\\n    return (vault, numVaults); \\n    // vaultId is numVaults after new creation of the vault.\\n\\n  }\\n}\",\"keccak256\":\"0xb2a4a70361bc856444096dbc2ff050b9749eb8518db1648bca1f6d8f8e5b6ea6\"},\"contracts/protocol/marketmanager.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./reputationtoken.sol\\\"; \\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VRFConsumerBaseV2} from \\\"../chainlink/VRFConsumerBaseV2.sol\\\";\\nimport {VRFCoordinatorV2Interface} from \\\"../chainlink/VRFCoordinatorV2Interface.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport {SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\"; \\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\"; \\n\\ncontract MarketManager \\n // VRFConsumerBaseV2 \\n {\\n  using FixedPointMathLib for uint256;\\n  using SafeTransferLib for ERC20;\\n\\n  // Chainlink state variables\\n  // VRFCoordinatorV2Interface COORDINATOR;\\n  // uint64 private immutable subscriptionId;\\n  // bytes32 private keyHash;\\n  // uint32 private callbackGasLimit = 100000;\\n  // uint16 private requestConfirmations = 3;\\n  // uint256 total_validator_bought; // should be a mapping no?\\n  bool private _mutex;\\n\\n  // ReputationNFT repToken;\\n  Controller controller;\\n  CoreMarketData[] public markets;\\n  address public owner; \\n\\n  // mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\\n  // mapping(uint256 => ValidatorData) validator_data;\\n  mapping(uint256=>uint256) public redemption_prices; //redemption price for each market, set when market resolves \\n  mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \\n  mapping(uint256=>mapping(address=>bool)) private assessment_trader;\\n  mapping(uint256=>mapping(address=>uint256) ) public assessment_probs; \\n  mapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\\n  mapping(uint256=> MarketParameters) public parameters; //marketId-> params\\n  mapping(uint256=> mapping(address=>bool)) private redeemed; \\n  mapping(uint256=> mapping(address=>uint256)) public longTrades; \\n  mapping(uint256=> mapping(address=>uint256)) public shortTrades;\\n  mapping(uint256=> uint256) public loggedCollaterals;\\n\\n  struct CoreMarketData {\\n    SyntheticZCBPool bondPool; \\n    ERC20 longZCB;\\n    ERC20 shortZCB; \\n    string description; // instrument description\\n    uint256 creationTimestamp;\\n    uint256 resolutionTimestamp;\\n    bool isPool; \\n  }\\n\\n  struct MarketPhaseData {\\n    bool duringAssessment;\\n    bool onlyReputable;\\n    bool resolved;\\n    bool alive;\\n    bool atLoss;\\n    // uint256 min_rep_score;\\n    uint256 base_budget;\\n  }\\n\\n  /// @param N: upper bound on number of validators chosen.\\n  /// @param sigma: validators' stake\\n  /// @param alpha: minimum managers' stake\\n  /// @param omega: high reputation's stake \\n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \\n  /// @param r: reputation percentile for reputation constraint phase\\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \\n  /// @param steak: steak*approved_principal is the staking amount.\\n  /// param beta: how much volatility managers are absorbing \\n  /// param leverage: how much leverage managers can apply \\n  /// param base_budget: higher base_budget means lower decentralization, \\n  /// @dev omega always <= alpha\\n  struct MarketParameters{\\n    uint256 N;\\n    uint256 sigma; \\n    uint256 alpha; \\n    uint256 omega;\\n    uint256 delta; \\n    uint256 r;\\n    uint256 s;\\n    uint256 steak;\\n  }\\n\\n  modifier onlyController(){\\n    require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"!controller\\\"); \\n    _;\\n  }\\n\\n\\n  modifier _lock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  constructor(\\n    address _creator_address,\\n    address _controllerAddress,\\n    address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\\n    bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\\n    uint64 _subscriptionId // 1713, \\n  ) \\n    //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) \\n  {\\n    controller = Controller(_controllerAddress);\\n    // keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\\n    // subscriptionId = 1713;\\n    // COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\\n    \\n    // push empty market\\n    markets.push(\\n      makeEmptyMarketData()\\n    );\\n\\n    owner = msg.sender; \\n  }\\n\\n  function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\\n    return CoreMarketData(\\n        SyntheticZCBPool(address(0)),\\n        ERC20(address(0)),\\n        ERC20(address(0)),\\n        \\\"\\\",\\n        0,\\n        0, \\n        false\\n      );\\n  }    \\n\\n  function marketCount() public view returns (uint256) {\\n    return markets.length;\\n  }\\n\\n  function getMarket(uint256 _id) public view returns (CoreMarketData memory) {\\n    if (_id >= markets.length) {\\n        return makeEmptyMarketData();\\n    } else {\\n        return markets[_id];\\n    }\\n  }\\n\\n  /// @notice parameters have to be set prior \\n  function newMarket(\\n    uint256 marketId,\\n    SyntheticZCBPool bondPool,  \\n    address _longZCB, \\n    address _shortZCB, \\n    string calldata _description, \\n    // uint256 _duration, \\n    bool isPool\\n    ) external onlyController {\\n    uint256 creationTimestamp = block.timestamp;\\n\\n    markets.push(CoreMarketData(\\n      bondPool, \\n      ERC20(_longZCB),\\n      ERC20(_shortZCB),  \\n      _description,\\n      creationTimestamp,\\n      0, //TODO resolution timestamp, \\n      isPool \\n    ));\\n\\n    uint256 base_budget = 1000 * config.WAD; //TODO \\n    setMarketPhase(marketId, true, true, base_budget);\\n\\n   // _validatorSetup(marketId, principal, creationTimestamp, _duration, isPool);\\n  }\\n\\n\\n  /*----Phase Functions----*/\\n\\n  /// @notice list of parameters in this system for each market, should vary for each instrument \\n  /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes \\n  /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower \\n  /// to borrow as it lowers approved principal and increases interest rate \\n  function setParameters(\\n    MarketParameters memory param,\\n    uint256 utilizationRate,\\n    uint256 marketId \\n    ) public onlyController{\\n    parameters[marketId] = param; \\n    parameters[marketId].s = param.s.mulWadDown(config.WAD - utilizationRate); // experiment\\n  }\\n\\n  /**\\n   @dev in the event that the number of traders in X percentile is less than the specified number of validators\\n   parameter N is changed to reflect this\\n   */\\n  function setN(uint256 marketId, uint256 _N) public onlyController {\\n    parameters[marketId].N = _N;\\n  }\\n\\n  /// @notice sets market phase data\\n  /// @dev called on market initialization by controller\\n  /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\\n  function setMarketPhase(\\n    uint256 marketId, \\n    bool duringAssessment,\\n    bool _onlyReputable,\\n    uint256 base_budget\\n    ) public onlyController{\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.onlyReputable = _onlyReputable; \\n    data.duringAssessment = duringAssessment;\\n    // data.min_rep_score = calcMinRepScore(marketId);\\n    data.base_budget = base_budget;\\n    data.alive = true;\\n  }\\n\\n  /// @notice used to transition from reputationphases \\n  function setReputationPhase(\\n    uint256 marketId,\\n    bool _onlyReputable\\n  ) public onlyController {\\n    restriction_data[marketId].onlyReputable = _onlyReputable;\\n  }\\n\\n  /// @notice Called when market should end, a) when denied b) when maturity \\n  /// @param resolve is true when instrument does not resolve prematurely\\n  function deactivateMarket(\\n    uint256 marketId, \\n    bool atLoss, \\n    bool resolve, \\n    uint256 rp) public onlyController{\\n    restriction_data[marketId].resolved = resolve; \\n    restriction_data[marketId].atLoss = atLoss; \\n    restriction_data[marketId].alive = false;\\n    redemption_prices[marketId] = rp; \\n\\n  } \\n\\n  /// @notice called by validator only\\n  function denyMarket(\\n    uint256 marketId\\n  ) external onlyController {\\n    //TODO should validators be able to deny even though they've approved.\\n    require(restriction_data[marketId].duringAssessment, \\\"!assessment\\\");\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.alive = false;\\n    data.resolved = true;\\n  }\\n\\n  /// @notice main approval function called by controller\\n  /// @dev if market is alive and market is not during assessment, it is approved. \\n  function approveMarket(uint256 marketId) onlyController external {\\n    restriction_data[marketId].duringAssessment = false;    \\n  }\\n\\n  function getPhaseData(\\n    uint256 marketId\\n  ) public view returns (MarketPhaseData memory)  {\\n    return restriction_data[marketId];\\n  }\\n\\n  \\n\\n  function isMarketApproved(uint256 marketId) public view returns(bool){\\n    return(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive);  \\n  }\\n\\n\\n\\n  /// @notice returns whether current market is in phase \\n  /// 1: onlyReputable, which also means market is in assessment\\n  /// 2: not onlyReputable but in asseessment \\n  /// 3: in assessment but canbeapproved \\n  /// 4: post assessment(accepted or denied), amortized liquidity \\n  function getCurrentMarketPhase(uint256 marketId) public view returns(uint256){\\n    if (restriction_data[marketId].onlyReputable){\\n      assert(!controller.marketCondition(marketId) && !isMarketApproved(marketId) && restriction_data[marketId].duringAssessment ); \\n      return 1; \\n    }\\n\\n    else if (restriction_data[marketId].duringAssessment && !restriction_data[marketId].onlyReputable){\\n      assert(!isMarketApproved(marketId)); \\n      if (controller.marketCondition(marketId)) return 3; \\n      return 2; \\n    }\\n\\n    else if (isMarketApproved( marketId)){\\n      assert (!restriction_data[marketId].duringAssessment && controller.marketCondition(marketId)); \\n      return 4; \\n    }\\n  }\\n\\n  /// @notice get trade budget = f(reputation), returns in collateral_dec\\n  /// sqrt for now\\n  function getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\\n    //uint256 repscore = repToken.getReputationScore(trader); \\n    uint256 repscore = controller.getTraderScore(trader);\\n    \\n    if (repscore==0) return 0; \\n\\n    return restriction_data[marketId].base_budget + (repscore*config.WAD).sqrt();\\n  }\\n \\n\\n  function getParameters(uint256 marketId) public view returns(MarketParameters memory){\\n    return parameters[marketId]; \\n  }\\n\\n  function getPool(uint256 marketId) public view returns(SyntheticZCBPool){\\n    return markets[marketId].bondPool; \\n  }\\n\\n  function getZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].longZCB;\\n  }\\n\\n  function getShortZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].shortZCB;\\n  }\\n  \\n\\n  /// @notice whether new longZCB can be issued \\n  function _canIssue(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n    ) internal view {\\n    if(queuedRepUpdates[trader] > queuedRepThreshold)\\n      revert(\\\"rep queue\\\"); \\n\\n    // if (!controller.isVerified(trader)) \\n    //   revert(\\\"!verified\\\");\\n\\n    if (getTraderBudget(marketId, trader) <= uint256(amount))\\n      revert(\\\"budget\\\");\\n\\n    if (controller.getTraderScore(trader) == 0)\\n      revert(\\\"!rep\\\"); \\n  }\\n\\n  /// @notice performs checks for buy function\\n  /// @param amount: collateral used to buy ZCB.\\n  function _canBuy(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n  ) internal view {\\n    //If after assessment there is a set buy threshold, people can't buy above this threshold\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n\\n    // TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n\\n    bool _duringMarketAssessment = restriction_data[marketId].duringAssessment;\\n    bool _onlyReputable =  restriction_data[marketId].onlyReputable;\\n\\n    if(amount>0){\\n      if (_duringMarketAssessment){\\n        _canIssue(trader, amount, marketId); \\n      }\\n    }\\n\\n    //During the early risk assessment phase only reputable can buy \\n    if (_onlyReputable){\\n      if (!controller.isReputable(trader, parameters[marketId].r)){\\n        revert(\\\"insufficient rep\\\");\\n      }\\n    }\\n  }\\n\\n  /// @notice amount is in zcb_amount_in TODO \\n  function _canSell(\\n    address trader,\\n    uint256 amount, \\n    uint256 marketId\\n  ) internal view returns(bool) {\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n\\n    //TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n\\n    if(restriction_data[marketId].duringAssessment) {\\n      // restrict attacking via disapproving the utilizer by just shorting a bunch\\n     // if(amount>= hedgeAmount) return false; \\n\\n      //else return true;\\n    }\\n    else{\\n      // restrict naked CDS amount\\n      \\n      // \\n    } \\n\\n    return true; \\n  }\\n\\n  // VALIDATOR FUNCTIONS\\n\\n  /**\\n   @notice called when the validator votes to approve the market => stakes vt + recieves discounted ZCB\\n   the staked amount goes to the controller while the discounted ZCB goes to the market manager.\\n   */\\n  function validatorApprove(\\n    uint256 marketId, \\n    uint256 collateral_required,\\n    uint256 zcb_for_sale,\\n    address validator\\n  ) external onlyController {\\n    loggedCollaterals[marketId] += collateral_required;\\n    SyntheticZCBPool bondPool = getPool(marketId); \\n    bondPool.BaseToken().transferFrom(validator, address(bondPool), collateral_required); \\n    bondPool.trustedDiscountedMint(validator, zcb_for_sale);\\n  }\\n\\n\\n\\n  /// @notice log how much collateral trader has at stake, \\n  /// to be used for redeeming, restricting trades\\n  function _logTrades(\\n    uint256 marketId,\\n    address trader, \\n    uint256 collateral,\\n    uint256 shortCollateral,  \\n    bool isBuy, \\n    bool isLong\\n    ) internal {\\n\\n    if (isLong){\\n\\n      // If buying bond during assessment, trader is manager, so should update \\n      if (isBuy) {\\n        longTrades[marketId][trader] += collateral; \\n        loggedCollaterals[marketId] += collateral; \\n        queuedRepUpdates[trader] += 1; \\n        } else {\\n        longTrades[marketId][trader] -= collateral;\\n        loggedCollaterals[marketId] -= collateral; \\n        } \\n      } else{\\n      if (isBuy) {\\n        // shortCollateral is amount trader pays to buy shortZCB\\n        shortTrades[marketId][trader] += shortCollateral;\\n\\n        // collateral is the area under the curve that is subtracted due to the (short)selling\\n        loggedCollaterals[marketId] -= collateral; \\n        } else {\\n        // revert if underflow, which means trader sold short at a profit, which is not allowed during assessment \\n        shortTrades[marketId][trader] -= shortCollateral; \\n        loggedCollaterals[marketId] += collateral; \\n      } \\n    }\\n  }\\n\\n  /// @notice general limitorder claim + liquidity provision funnels used post-assessment, \\n  /// which will be recorded if necessary \\n  /// param type: 1 if open long, 2 if close long, 3 if open short, 4 if close short\\n  /// type 5: partially claim , TODO do all possible trading functions \\n  function claimFunnel(\\n    uint256 marketId, \\n    uint16 point, \\n    uint256 funnel\\n    ) external returns(uint256 claimedAmount){\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    if (funnel == 1) claimedAmount = bondPool.makerClaimOpen(point,true, msg.sender); \\n    else if (funnel == 2) claimedAmount = bondPool.makerClaimClose(point,true, msg.sender);\\n    else if (funnel == 3) claimedAmount = bondPool.makerClaimOpen(point,false, msg.sender); \\n    else if (funnel == 4) claimedAmount = bondPool.makerClaimClose(point,false, msg.sender); \\n  }\\n\\n  /// @notice called by pool when buying, transfers funds from trader to pool \\n  function tradeCallBack(uint256 amount, bytes calldata data) external{\\n    SyntheticZCBPool(msg.sender).BaseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \\n  }\\n\\n\\n\\n  /// @notice after assessment, let managers buy newly issued longZCB if the instrument is pool based \\n  /// funds + funds * levFactor will be directed to the instrument \\n  function issuePoolBond(\\n    uint256 _marketId, \\n    uint256 _amountIn\\n    ) external _lock_ {\\n    require(!restriction_data[_marketId].duringAssessment, \\\"Pre Approval\\\"); \\n    _canIssue(msg.sender, int256(_amountIn), _marketId);  \\n    Vault vault = controller.getVault(_marketId); \\n\\n    // Get price and sell longZCB with this price\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(_marketId);\\n    markets[_marketId].bondPool.BaseToken().transferFrom(msg.sender, address(vault), _amountIn);\\n    uint256 issueQTY = _amountIn.divWadDown(pju); \\n    markets[_marketId].bondPool.trustedDiscountedMint(msg.sender, issueQTY); \\n\\n    // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \\n    vault.depositIntoInstrument(_marketId, _amountIn + issueQTY.mulWadDown(levFactor).mulWadDown(psu)); \\n  }\\n\\n  /// @notice when a manager redeems a poollongzcb, redeemAmount*levFactor are automatically \\n  /// withdrawn from the instrument\\n  function redeemPoolLongZCB(\\n    uint256 marketId, \\n    uint256 redeemAmount\\n    ) external _lock_ returns(uint256 collateral_redeem_amount, uint256 seniorAmount){\\n    require(!restriction_data[marketId].alive, \\\"!market\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!market\\\"); \\n\\n    Vault vault = controller.getVault(marketId); \\n    CoreMarketData memory market = markets[marketId]; \\n\\n    require(market.isPool, \\\"!pool\\\"); \\n    require(market.longZCB.balanceOf(msg.sender) > redeemAmount, \\\"insufficient bal\\\"); \\n\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(marketId);\\n    collateral_redeem_amount = pju.mulWadDown(redeemAmount); \\n    seniorAmount = redeemAmount.mulWadDown(levFactor).mulWadDown(psu); \\n\\n    // Need to check if redeemAmount*levFactor can be withdrawn from the pool and do so\\n    vault.withdrawFromInstrumentExternal(marketId, seniorAmount); \\n\\n    // TODO update reputation \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n\\n    market.bondPool.trustedBurn(msg.sender, redeemAmount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  mapping(address => uint8) public queuedRepUpdates; \\n  uint8 public constant queuedRepThreshold = 3; // at most 3 simultaneous assessment per manager\\n\\n  /// @notice main entry point for longZCB buys \\n  /// @param _amountIn is negative if specified in zcb quantity\\n  function buyBond(\\n    uint256 _marketId, \\n    int256 _amountIn, \\n    uint256 _priceLimit, \\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    _canBuy(msg.sender, _amountIn, _marketId);\\n\\n    CoreMarketData memory marketData = markets[_marketId]; \\n    SyntheticZCBPool bondPool = marketData.bondPool; \\n    \\n    // During assessment, real bonds are issued from utilizer, they are the sole LP \\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender)); \\n      //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n      _logTrades(_marketId, msg.sender, amountIn, 0, true, true);\\n\\n      // Get implied probability estimates by summing up all this manager bought for this market \\n      assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n          getZCB(_marketId).balanceOf(msg.sender) + leveragePosition[_marketId][msg.sender].amount, \\n          longTrades[_marketId][msg.sender], \\n          getTraderBudget(_marketId, msg.sender) \\n      ); \\n\\n      // Phase Transitions when conditions met\\n      if(restriction_data[_marketId].onlyReputable){\\n        uint256 total_bought = loggedCollaterals[_marketId];\\n\\n        if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n              controller\\n              .getVault(_marketId)\\n              .fetchInstrumentData(_marketId)\\n              .principal)\\n        ) {\\n          restriction_data[_marketId].onlyReputable = false;\\n        }\\n      }\\n    }\\n\\n    // Synthetic bonds are issued (liquidity provision are amortized as counterparties)\\n    else{\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if(isTaker)\\n        (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), true, msg.sender); \\n      }\\n    }\\n  }\\n\\n  /// @notice longZCB sells  \\n  /// @param _amountIn quantity in longZCB \\n  function sellBond(\\n      uint256 _marketId,\\n      uint256 _amountIn, \\n      uint256 _priceLimit, \\n      bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    // if (duringMarketAssessment(_marketId)) revert(\\\"can't close during assessment\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      (amountIn, amountOut) = bondPool.takerClose(\\n                                    true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountIn, 0, false, true );                                          \\n\\n    }\\n    else{\\n      controller.deduct_selling_fee( _marketId ); //TODO, if validator or manager, deduct reputation \\n\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if(isTaker) (amountIn, amountOut) = bondPool.takerClose(\\n              true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      else {\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, uint256(_amountIn), true, msg.sender);        \\n      }\\n    }\\n  } \\n\\n  /// @param _amountIn: amount of short trader is willing to buy\\n  /// @param _priceLimit: slippage tolerance on trade\\n  function shortBond(\\n    uint256 _marketId,\\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is base collateral down the curve, amountIn is collateral used to buy shortZCB \\n      (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false);\\n\\n    }\\n    else{\\n      //deduct_selling_fee(); //if naked CDS( staked vault)\\n\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), false, msg.sender);\\n      }\\n    }\\n  }\\n\\n  /// @param _amountIn is amount of short trader is willing to cover \\n  function coverBondShort(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is collateral up the curve, amountIn is collateral returned from closing  \\n      (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false); \\n     // deduct_selling_fee(); \\n    }\\n    else{\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, _amountIn, false, msg.sender);\\n      }\\n    }\\n  }\\n\\n\\n  /// @notice called by traders when market is denied before approval TODO\\n  /// ??? if the market is denied, this function is called and everything is redeemed \\n  /// validator will need to call this on denial + isLong = true to redeem their collateral.\\n  function redeemDeniedMarket(\\n    uint256 marketId, \\n    bool isLong\\n  ) external _lock_ {\\n    require(!restriction_data[marketId].alive, \\\"Market Still During Assessment\\\"); // TODO\\n    require(restriction_data[marketId].duringAssessment, \\\"Market has been approved\\\");\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 collateral_amount;\\n    uint256 balance; \\n    // Get collateral at stake in shorts, which will be directly given back to traders\\n    if(!isLong){\\n      balance = markets[marketId].shortZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      collateral_amount = shortTrades[marketId][msg.sender]; \\n      delete shortTrades[marketId][msg.sender]; \\n\\n      //Burn all their balance\\n      bondPool.trustedBurn(msg.sender, balance, false);\\n    } \\n\\n    // Get collateral at stake in longs, which will be directly given back to traders\\n    else {\\n      balance = markets[marketId].longZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      if (controller.isValidator(marketId, msg.sender) && controller.hasApproved(marketId, msg.sender)) {\\n        collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n      }\\n      else{\\n        collateral_amount = longTrades[marketId][msg.sender]; \\n        delete longTrades[marketId][msg.sender]; \\n      }\\n\\n      // Burn all their balance \\n      bondPool.trustedBurn(msg.sender, balance, true); \\n      \\n      // This means that the sender is a manager\\n      if (queuedRepUpdates[msg.sender] > 0){\\n        unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n      }    \\n    }\\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount, msg.sender, marketId);\\n    //TODO need to check if last redeemer, so can kill market.\\n  }\\n\\n  /// @notice trader will redeem entire balance of ZCB\\n  /// Needs to be called at maturity, market needs to be resolved first(from controller)\\n  function redeem(\\n    uint256 marketId\\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender);\\n\\n    uint256 zcb_redeem_amount = markets[marketId].longZCB.balanceOf(msg.sender); \\n    uint256 redemption_price = redemption_prices[marketId]; \\n    collateral_redeem_amount = redemption_price.mulWadDown(zcb_redeem_amount); \\n\\n    if (!controller.isValidator(marketId, msg.sender)) { // TODO should validators get reputation if they do ok.\\n      bool increment = redemption_price >= config.WAD? true: false;\\n      controller.updateReputation(marketId, msg.sender, increment);\\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n   }\\n\\n    bondPool.trustedBurn(msg.sender, zcb_redeem_amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n\\n  }\\n\\n  /// @notice called by short buyers when market is resolved  \\n  function redeemShortZCB(\\n    uint256 marketId \\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 shortZCB_redeem_amount = markets[marketId].shortZCB.balanceOf(msg.sender); \\n    uint256 long_redemption_price = redemption_prices[marketId];\\n    uint256 redemption_price = long_redemption_price >= config.WAD \\n                               ? 0 \\n                               : config.WAD - long_redemption_price; \\n    collateral_redeem_amount = redemption_price.mulWadDown(shortZCB_redeem_amount);\\n\\n    bondPool.trustedBurn(msg.sender, shortZCB_redeem_amount, false); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  /// @notice returns the manager's maximum leverage \\n  function getMaxLeverage(address manager) public view returns(uint256){\\n    //return (repToken.getReputationScore(manager) * config.WAD).sqrt(); //TODO experiment \\n    return (controller.getTraderScore(manager) * config.WAD).sqrt();\\n  }\\n\\n  mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \\n  struct LeveredBond{\\n    uint128 debt; //how much collateral borrowed from vault \\n    uint128 amount; // how much bonds were bought with the given leverage\\n  }\\n\\n  /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\\n  /// capital efficient with their zcb purchase. \\n  /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\\n  /// is _amountIn/_leverage \\n  /// @dev the marketmanager should take custody of the quantity bought with leverage\\n  /// and instead return notes of the levered position \\n  /// TODO do + instead of creating new positions and implied prob cumulative \\n  function buyBondLevered(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit, \\n    uint256 _leverage //in 18 dec \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(restriction_data[_marketId].duringAssessment, \\\"PhaseERR\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= config.WAD, \\\"!leverage\\\");\\n    _canBuy(msg.sender, int256(_amountIn), _marketId);\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    // stack collateral from trader and borrowing from vault \\n    uint256 amountPulled = _amountIn.divWadDown(_leverage); \\n    bondPool.BaseToken().transferFrom(msg.sender, address(this), amountPulled); \\n    controller.pullLeverage(_marketId, _amountIn - amountPulled); \\n\\n    // Buy with leverage, zcb transferred here\\n    bondPool.BaseToken().approve(address(this), _amountIn); \\n    (amountIn, amountOut) = bondPool.takerOpen(true, int256(_amountIn), _priceLimit, abi.encode(address(this))); \\n\\n    //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n    _logTrades(_marketId, msg.sender, _amountIn, 0, true, true);\\n\\n    // Get implied probability estimates by summing up all this managers bought for this market \\n    assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n        amountOut, \\n        amountIn, \\n        getTraderBudget(_marketId, msg.sender) \\n    ); \\n\\n    // Phase Transitions when conditions met\\n    if(restriction_data[_marketId].onlyReputable){\\n      uint256 total_bought = loggedCollaterals[_marketId];\\n\\n      if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n            controller\\n            .getVault(_marketId)\\n            .fetchInstrumentData(_marketId)\\n            .principal)\\n      ) {\\n        restriction_data[_marketId].onlyReputable = false;\\n      }\\n    }\\n    // create note to trader \\n    leveragePosition[_marketId][msg.sender] = LeveredBond(uint128(_amountIn - amountPulled ),uint128(amountOut)) ; \\n  }\\n\\n  function redeemLeveredBond(uint256 marketId) public{\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \\n\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n\\n    uint256 redemption_price = redemption_prices[marketId]; \\n    uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \\n    uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \\n        ? collateral_back - uint256(position.debt) : 0; \\n\\n    if (!controller.isValidator(marketId, msg.sender)) {\\n      bool increment = redemption_price >= config.WAD? true: false;\\n      controller.updateReputation(marketId, msg.sender, increment);\\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n\\n    leveragePosition[marketId][msg.sender].amount = 0; \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n    leveragePosition[marketId][msg.sender].amount = 0; \\n\\n    // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n    if (controller.isValidator(marketId, msg.sender)) {\\n      collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n    }\\n    else{\\n      collateral_amount = longTrades[marketId][msg.sender]; \\n      delete longTrades[marketId][msg.sender]; \\n    }\\n\\n    // Burn all their position, \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n      unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }    \\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount - uint256(position.debt), msg.sender, marketId);\\n  }\\n}\\n\\n\",\"keccak256\":\"0x1e0ddec96f0c4bb001f0fbdcf402dd9d9ce38a56655b58a4b26252cf05bdf310\"},\"contracts/protocol/reputationmanager.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport {config} from \\\"../utils/helpers.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ncontract ReputationManager {\\n    using FixedPointMathLib for uint256;\\n\\n    mapping(address=>uint256) public trader_scores; // trader address => score\\n    mapping(address=>bool) public isRated;\\n    address[] public traders;\\n\\n    address controller;\\n    address marketManager;\\n\\n    address deployer;\\n\\n    modifier onlyProtocol() {\\n        require(msg.sender == controller || msg.sender == marketManager || msg.sender == deployer);\\n        _;\\n    }\\n\\n    \\n\\n    constructor(\\n        address _controller,\\n        address _marketManager\\n    ) {\\n       controller = _controller;\\n       marketManager = _marketManager;\\n       deployer = msg.sender;\\n    }\\n\\n    function calculateMinScore(uint256 percentile) view external returns (uint256) {\\n        uint256 l = traders.length * config.WAD;\\n        if (percentile / 1e2 == 0) {\\n        return 0;\\n        }\\n        uint256 x = l.mulWadDown(percentile / 1e2);\\n        x /= config.WAD;\\n        return trader_scores[traders[x - 1]];\\n    }\\n\\n    // change visiblity, external only for testing.\\n    function setTraderScore(address trader, uint256 score) external {\\n        uint256 prev_score = trader_scores[trader];\\n        if (score > prev_score) {\\n        incrementScore(trader, score - prev_score);\\n        } else if (score < prev_score) {\\n        decrementScore(trader, prev_score - score);\\n        }\\n    }\\n    \\n    function isReputable(address trader, uint256 percentile) view external returns (bool) {\\n        uint256 k = findTrader(trader);\\n        uint256 n = (traders.length - (k+1))*config.WAD;\\n        uint256 N = traders.length*config.WAD;\\n        uint256 p = uint256(n).divWadDown(N)*10**2;\\n\\n        if (p >= percentile) {\\n        return true;\\n        } else {\\n        return false;\\n        }\\n    }\\n\\n    /**\\n    @dev percentile is is wad 0-100\\n    @notice returns a list of top X percentile traders excluding the utilizer. \\n    */\\n    function filterTraders(uint256 percentile, address utilizer) view public returns (address[] memory) {\\n        uint256 l = traders.length * config.WAD;\\n        \\n        // if below minimum percentile, return all traders excluding the utilizer\\n        if (percentile / 1e2 == 0) {\\n        if (isRated[utilizer]) {\\n            address[] memory result = new address[](traders.length - 1);\\n\\n            uint256 j = 0;\\n            for (uint256 i=0; i<traders.length; i++) {\\n            if (utilizer == traders[i]) {\\n                j = 1;\\n                continue;\\n            }\\n            result[i - j] = traders[i];\\n            }\\n            return result;\\n        } else {\\n            return traders;\\n        }\\n        }\\n\\n        uint256 x = l.mulWadDown((config.WAD*100 - percentile) / 1e2);\\n        x /= config.WAD;\\n\\n        address[] memory selected; \\n        if (utilizer == address(0) || !isRated[utilizer]) {\\n        selected = new address[](x);\\n        for (uint256 i=0; i<x; i++) {\\n            selected[i] = traders[i];\\n        }\\n        } else {\\n        selected = new address[](x - 1);\\n        uint256 j=0;\\n        for (uint256 i = 0; i<x; i++) {\\n            if (traders[i] == utilizer) {\\n            j = 1;\\n            continue;\\n            }\\n            selected[i - j] = traders[i];\\n        }\\n        }\\n\\n        return selected;\\n    }\\n\\n    function getTraders() view public returns (address[] memory) {\\n        return traders;\\n    }\\n\\n    /**\\n    @notice increments trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function incrementScore(address trader, uint256 update) onlyProtocol public {\\n        trader_scores[trader] += update;\\n        _updateRanking(trader, true);\\n    }\\n\\n    /**\\n    @notice decrements trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function decrementScore(address trader, uint256 update) onlyProtocol public {\\n        if (update >= trader_scores[trader]) {\\n        trader_scores[trader] = 0;\\n        } else {\\n        trader_scores[trader] -= update;\\n        }\\n        _updateRanking(trader, false);\\n    }\\n\\n    /**\\n    @notice updates top trader array\\n    @dev holy moly is this ugly\\n    */\\n    function _updateRanking(address trader, bool increase) internal {\\n        uint256 score = trader_scores[trader];\\n\\n        if (!isRated[trader]) {\\n        isRated[trader] = true;\\n        if (traders.length == 0) {\\n            traders.push(trader);\\n            return;\\n        }\\n        for (uint256 i=0; i<traders.length; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n            traders.push(address(0));\\n            _shiftRight(i, traders.length-1);\\n            traders[i] = trader;\\n            return;\\n            }\\n            if (i == traders.length - 1) {\\n            traders.push(trader);\\n            return;\\n            }\\n        }\\n        } else {\\n        uint256 k = findTrader(trader);\\n        //swap places with someone.\\n        if ((k == 0 && increase)\\n        || (k == traders.length - 1 && !increase)) {\\n            return;\\n        }\\n\\n        if (increase) {\\n            for (uint256 i=0; i<k; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n                _shiftRight(i,k);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        } else {\\n            for (uint256 i=traders.length - 1; i>k; i--) {\\n            if (score < trader_scores[traders[i]]) {\\n                _shiftLeft(k, i);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        }\\n        }\\n    }\\n\\n    function findTrader(address trader) public view returns (uint256) {\\n    for (uint256 i=0; i<traders.length; i++) {\\n        if (trader == traders[i]) {\\n            return i;\\n        }\\n        }\\n    }\\n\\n    /**\\n    @notice helpers\\n    */\\n    function _shiftRight(uint256 pos, uint256 end) internal {\\n        for (uint256 i=end; i>pos; i--) {\\n        traders[i] = traders[i-1];\\n        }\\n    }\\n\\n    function _shiftLeft(uint256 pos, uint256 end) internal {\\n        for (uint256 i=pos; i<end; i++) {\\n        traders[i] = traders[i+1];\\n        }\\n    }\\n    \\n}\",\"keccak256\":\"0xd8962780368ac821c63f4f4af8aad63fcf81b5ed5c7fdf9b3bba800c7406f886\"},\"contracts/protocol/reputationtoken.sol\":{\"content\":\"pragma solidity ^0.8.4; \\n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\\nimport {ERC721} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n\\ncontract ReputationNFT is ERC721 {\\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\\n  mapping(address => uint256) internal _ownerToId;\\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\\n\\n  uint256 private nonce = 1;\\n  Controller controller;\\n  uint256 SCALE = 1e18;\\n\\n\\n  struct ReputationData {\\n    uint256 n; // number of markets participated in => regular uint256\\n    uint256 score; \\n  }\\n\\n  struct TraderData { // for each market\\n    address trader;\\n    uint256 tokensBought;\\n  }\\n\\n  struct TopReputation{\\n    address trader; \\n    uint256 score; \\n  }\\n\\n  uint256 private constant topRep = 100; \\n  TopReputation[topRep] topReputations; \\n\\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\\n  mapping(uint256=>bool) allowAll; \\n  mapping(address=>bool) isUnique; \\n  address[] unique_traders; \\n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\\n\\n  modifier onlyController() {\\n    require(msg.sender == address(controller));\\n    _;\\n  }\\n\\n  constructor (\\n    address _controller\\n  ) ERC721(\\\"Debita Reputation Token\\\", \\\"DRT\\\") {\\n    controller = Controller(_controller);\\n  }\\n\\n  /**\\n   @notice incrementBalance\\n   */\\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\\n    balances[marketId][trader] += amount;\\n  }\\n\\n  /**\\n   @notice called post reputation update\\n   */\\n  function removeBalance(uint256 marketId, address trader) external onlyController {\\n    delete balances[marketId][trader];\\n  }\\n\\n  function _baseURI() internal pure returns (string memory baseURI) {\\n    baseURI = \\\"\\\";\\n  }\\n\\n  function tokenURI(uint256 id) public view override returns (string memory) {\\n    require(_ownerOf[id] != address(0), \\\"Invalid Identifier\\\");\\n\\n    string memory baseURI = _baseURI();\\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \\\"\\\";\\n  }\\n\\n  function mint(address to) external {\\n    require(_ownerToId[to] == uint256(0), \\\"can only mint one reputation token\\\");\\n    super._mint(to, nonce);\\n    _ownerToId[to] = nonce;\\n\\n    // Set default score, if this goes to 0 cannot trade\\n    _reputation[_ownerToId[to]].score = 1e18; \\n\\n    nonce++;\\n  }\\n\\n  function getReputationScore(address owner) view external returns (uint256){\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score;\\n  }\\n\\n  function setReputationScore(address owner, uint256 score) external returns (uint256) \\n  //onlyOwner\\n  {\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score = score;\\n  }\\n\\n\\n  function updateScore(address to, int256 score) external onlyController{\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (score > 0) data.score = data.score + uint256(score);\\n    else{\\n        if (data.score <= uint256(-score)) data.score = 0; \\n        else data.score = data.score - uint256(-score);\\n      } \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n\\n  function addScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    data.score = data.score + score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function decrementScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (data.score <= score) data.score = 0; \\n    else data.score = data.score - score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function addAverageScore(address to, uint256 score) external onlyController\\n\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    \\n    if (data.n == 0) {\\n      data.score = score;\\n    } else {\\n      data.score = (data.score / data.n + score) / (data.n + 1);\\n    }\\n\\n    data.n++;\\n  }\\n\\n  /**\\n   @notice reset scores\\n   */\\n  function resetScore(address to) external {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n    delete _reputation[_ownerToId[to]];\\n  }\\n\\n  /// @notice called by controller when initiating market,\\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\\n    if (getAvailableTopX() < topX) {\\n      allowAll[marketId] =true; \\n      return; \\n    }\\n\\n    for (uint256 i; i<topX; i++){\\n      canTrade[marketId][topReputations[i].trader] = true;\\n    }\\n\\n  }\\n\\n  /// @notice gets the x's ranked score from all reputation scores \\n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\\n  /// during reputation constraint periods \\n  function getMinRepScore(uint256 topX) public view returns(uint256) {\\n    if (getAvailableTopX() < topX) {\\n      return 0; \\n    }\\n    return topReputations[topX].score;\\n  }\\n\\n  function getAvailableTopX() public view returns(uint256){\\n    return unique_traders.length; \\n  }\\n\\n  function getAvailableTraderNum() public view returns(uint256){\\n    return nonce -1; \\n  }\\n\\n  /// @notice whether trader is above reputation threshold \\n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \\n  }\\n\\n  /// @notice called whenever a score is incremented   \\n  function storeTopX(uint256 score, address trader) internal {\\n    uint256 i = 0;\\n\\n    for(i; i < topReputations.length; i++) {\\n      if(topReputations[i].score < score) {\\n        break;\\n      }\\n    }\\n    // shifting the array of position (getting rid of the last element) \\n    for(uint j = topReputations.length - 1; j > i; j--) {\\n        topReputations[j].score = topReputations[j - 1].score;\\n        topReputations[j].trader = topReputations[j - 1].trader;\\n    }\\n    // update the new max element \\n    topReputations[i].score = score;\\n    topReputations[i].trader = trader;\\n\\n    if (isUnique[trader]) return; \\n    isUnique[trader] = true; \\n    unique_traders.push(trader);\\n\\n  }\\n\\n  function testStore() public view {\\n    for (uint i=0; i<10; i++){\\n      console.log('score', topReputations[i].score); \\n    }\\n  }  \\n}\",\"keccak256\":\"0x27ce24a964ca2dcb0f4452d75d6ab5d9ee7e91540363d54ca98b2fd8d1d9407c\"},\"contracts/utils/helpers.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nlibrary config{\\n\\n  uint256 public constant WAD_PRECISION = 18; \\n  uint256 public constant WAD = 1e18; \\n  uint256 public constant USDC_dec = 1e6; \\n  uint256 public constant roundLimit = 1e14; //0.0001 \\n\\n  //Max amount in one transaction \\n  uint256 private constant max_amount = 1e8 * WAD; \\n\\n  //Min amount in one transaction \\n  uint256 private constant min_amount = WAD/1e4; \\n\\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    //number should not be 18 dec, but in collateral_dec\\n    new_number = number * (10 ** (WAD_PRECISION - dec));\\n    assert(new_number <= max_amount); \\n  }\\n\\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    // number should be 18 dec \\n    assert(isInWad(number)); \\n    new_number = number/(10 ** (WAD_PRECISION - dec)); \\n\\n  }\\n\\n  function isInWad(uint256 number) internal pure returns(bool){\\n    return (number >= min_amount); \\n  }\\n\\n\\n\\n\\n}\",\"keccak256\":\"0xd30e0b9fdc4387086c91449032c63c8190e50bd580306e1e2a0b0dccbf735779\"},\"contracts/vaults/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n    mapping(address=>bool) Authorized; \\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return(user == owner || Authorized[user]);\\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setNewAuthority(address newAuthority) public {\\n        require(msg.sender == owner );\\n        Authorized[newAuthority] = true; \\n\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x46c0e8d518396b50d7dc7f0050d716a5643afad9320b0cd27490fd8e00689dc7\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/instrument.sol\":{\"content\":\"\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport \\\"./vault.sol\\\";\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\nabstract contract Instrument {\\n\\n    modifier onlyUtilizer() {\\n        require(msg.sender == Utilizer, \\\"!Utilizer\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \\\"!authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == address(vault), \\\"caller must be vault\\\");\\n        _;\\n    }\\n\\n    modifier notLocked() {\\n        require(!locked); \\n        _; \\n    }\\n\\n    constructor (\\n        address _vault,\\n        address _Utilizer\\n    ) {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    ERC20 public underlying;\\n    Vault public vault; \\n    bool locked; \\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private maturity_balance; \\n\\n    /// @notice address of user who submits the liquidity proposal \\n    address public Utilizer; \\n    address[] public validators; //set when deployed, but can't be ch\\n    mapping(address=>bool) isValidator; \\n\\n    /**\\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\\n     */\\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\\n\\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\\n        require(_Utilizer != address(0));\\n        Utilizer = _Utilizer;\\n    }\\n\\n    // function setValidator(address _validator) external {\\n    //     require(msg.sender == vault.owner(), \\\"Not owner\\\"); \\n    //     validators.push(_validator); \\n    //     isValidator[_validator] = true;     \\n    // }\\n\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\\n        return underlying.transfer(address(vault), amount); \\n    }\\n\\n    /// @notice Returns a user's Instrument balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Instrument balance in underlying tokens.\\n    /// @dev May mutate the state of the Instrument by accruing interest.\\n    function balanceOfUnderlying(address user) public view returns (uint256){\\n        return underlying.balanceOf(user); \\n    }\\n\\n\\n    /**\\n     * @notice\\n     *  Provide an accurate estimate for the total amount of assets\\n     *  (principle + return) that this Instrument is currently managing,\\n     *  denominated in terms of Underlying tokens.\\n     *\\n     *  This total should be \\\"realizable\\\" e.g. the total value that could\\n     *  *actually* be obtained from this Instrument if it were to divest its\\n     *  entire position based on current on-chain conditions.\\n     * @dev\\n     *  Care must be taken in using this function, since it relies on external\\n     *  systems, which could be manipulated by the attacker to give an inflated\\n     *  (or reduced) value produced by this function, based on current on-chain\\n     *  conditions (e.g. this function is possible to influence through\\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\\n     *  mechanisms).\\n     *\\n     *  It is up to governance to use this function to correctly order this\\n     *  Instrument relative to its peers in the withdrawal queue to minimize\\n     *  losses for the Vault based on sudden withdrawals. This value should be\\n     *  higher than the total debt of the Instrument and higher than its expected\\n     *  value to be \\\"safe\\\".\\n     *  Estimated Total assets should be \\n\\n     * @return The estimated total assets in this Strategy.\\n     */\\n    function estimatedTotalAssets() public view virtual returns (uint256){}\\n\\n\\n    /// @notice Free up returns for vault to pull,  checks if the instrument is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view virtual returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \\n    /// for this instrument to resolve \\n    /// For creditlines, all debts should be repaid\\n    /// for strategies, all assets should be divested + converted to Underlying\\n    /// this function is important in preventing manipulations, \\n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\\n    function prepareWithdraw()\\n        external \\n        onlyVault \\n        virtual\\n        returns (\\n            uint256 _profit,\\n            uint256 _loss,\\n            uint256 _debtPayment\\n        ){\\n            require(readyForWithdrawal(), \\\"not ready to withdraw\\\"); \\n\\n            // Lock additional drawdowns or usage of instrument balance \\n            lockLiquidityFlow();    \\n\\n        }\\n\\n    /**\\n     * Liquidate up to `_amountNeeded` of `underlying` of this strategy's positions,\\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\\n     * This function should return the amount of `underlying` tokens made available by the\\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\\n     * difference is due to a realized loss, or if there is some other sitution at play\\n     * (e.g. locked funds) where the amount made available is less than what is needed.\\n     *\\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\\n     */\\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\\n\\n    /**\\n     * Liquidate everything and returns the amount that got freed.\\n     * This function is used during emergency exit instead of `prepareReturn()` to\\n     * liquidate all of the instrument's positions back to the Vault.\\n     */\\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\\n\\n    function lockLiquidityFlow() internal{\\n        locked = true; \\n    }\\n\\n    function isLocked() public view returns(bool){\\n        return locked; \\n    }\\n\\n\\n    function transfer_liq(address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transfer(to, amount);\\n    }\\n\\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transferFrom(from, to, amount);\\n    }\\n\\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \\n    function store_internal_balance() external onlyVault{\\n\\n        maturity_balance = balanceOfUnderlying(address(this)); \\n        if (vault.decimal_mismatch()) maturity_balance = vault.decAssetsToShares(maturity_balance); \\n\\n    }\\n\\n    function getMaturityBalance() public view returns(uint256){\\n        return maturity_balance; \\n    }\\n\\n    function isLiquid(uint256 amount) public virtual view returns(bool){}\\n\\n\\n    /// @notice Before supplying liquidity from the vault to this instrument,\\n    /// which is done automatically when instrument is trusted, \\n    /// need to check if certain conditions that are required to this specific \\n    /// instrument is met. For example, for a creditline with a collateral \\n    /// requirement need to check if this address has the specific amount of collateral\\n    /// @dev called to be checked at the approve phase from controller  \\n    function instrumentApprovalCondition() public virtual view returns(bool); \\n}\\n\\n\\n// contract RevenueToken is ERC20{\\n\\n// }\\n\\n \\n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\\n/// approved borrowers will interact with this contract to borrow, repay. \\n/// and vault will supply principal and harvest principal/interest \\ncontract CreditLine is Instrument {\\n    using FixedPointMathLib for uint256;\\n    address public immutable borrower; \\n\\n    //  variables initiated at creation\\n    uint256 principal;\\n    uint256 notionalInterest; \\n    uint256 faceValue; //total amount due, i.e principal+interest\\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \\n    uint256 interestAPR; \\n\\n    // Modify-able Global Variables during repayments, borrow\\n    uint256 totalOwed; \\n    uint256 principalOwed; \\n    uint256 interestOwed;\\n    uint256 accumulated_interest; \\n    uint256 principalRepayed;\\n    uint256 interestRepayed; \\n\\n    // Collateral Info \\n    enum CollateralType{\\n        liquidateAble, \\n        nonLiquid, \\n        ownership \\n    }\\n    address public collateral; \\n    address public oracle; \\n    uint256 public collateral_balance; \\n    CollateralType public collateral_type; \\n\\n    uint256 drawdown_block; \\n    bool didDrawdown; \\n\\n    uint256 gracePeriod; \\n    uint256 resolveBlock; \\n    uint256 constant DUST = 1e18; //1usd\\n\\n    enum LoanStatus{\\n        notApproved,\\n        approvedNotDrawdowned,\\n        drawdowned, \\n        partially_repayed,\\n\\n        prepayment_fulfilled, \\n        matured, \\n        grace_period, \\n        isDefault\\n    }\\n\\n    LoanStatus public loanStatus; \\n\\n    uint256 lastRepaymentTime; \\n    uint256 gracePeriodStart; \\n    Proxy proxy; \\n\\n    /// @notice both _collateral and _oracle could be 0\\n    /// address if fully uncollateralized or does not have a price oracle \\n    /// param _notionalInterest and _principal is initialized as desired variables\\n    constructor(\\n        address vault,\\n        address _borrower, \\n        uint256 _principal,\\n        uint256 _notionalInterest, \\n        uint256 _duration,\\n        uint256 _faceValue,\\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \\n        address _oracle, // oracle for price of collateral \\n        uint256 _collateral_balance, //promised collateral balance\\n        uint256 _collateral_type\\n    )  Instrument(vault, _borrower) {\\n        borrower = _borrower; \\n        principal = _principal; \\n        notionalInterest = _notionalInterest; \\n        duration = _duration;   \\n        faceValue = _faceValue;\\n\\n        collateral = _collateral; \\n        oracle = _oracle; \\n        collateral_balance = _collateral_balance; \\n        collateral_type = CollateralType(_collateral_type); \\n\\n        loanStatus = LoanStatus.notApproved; \\n\\n        proxy = new Proxy(address(this), _borrower); \\n    }\\n\\n    function getCurrentTime() internal view returns(uint256){\\n        return block.timestamp + 31536000/2; \\n    }\\n    function getProxy() public view returns(address){\\n        return address(proxy); \\n    }\\n\\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view override returns(bool){\\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \\n        return true; \\n        //return false  \\n    }\\n\\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\\n\\n        return (0,0); \\n    }\\n\\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\\n    /// and push back to vault. If not possible, push the collateral back to\\n    function liquidateAndPushToVault() internal  {}\\n    function auctionAndPushToVault() internal {} \\n    function isLiquidatable(address collateral) public view returns(bool){}\\n\\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \\n    /// and return ratio to principal \\n    function getCollateralRatio() public view returns(uint256){\\n\\n    }\\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \\n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \\n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\\n        // TODO implement auction \\n        proxy.changeOwnership(buyer);\\n    }\\n\\n    /// @notice transfers collateral back to vault when default \\n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n        ERC20(collateral).transfer(to, amount); \\n    }\\n\\n\\n\\n    /// @notice validators have to check these conditions at a human level too before approving \\n    function instrumentApprovalCondition() public override view returns(bool){\\n        // check if borrower has correct identity \\n\\n        // check if enough collateral has been added as agreed   \\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid){\\n            require(ERC20(collateral).balanceOf(address(this)) >= collateral_balance, \\\"Insufficient collateral\\\"); \\n        }\\n\\n        // // check if validator(s) are set \\n        // if (validators.length == 0) {revert(\\\"No validators\\\"); }\\n\\n        // Check if proxy has been given ownership\\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\\\"Ownership \\\"); \\n\\n        return true; \\n    } \\n\\n    /// @notice borrower deposit promised collateral  \\n    function depositCollateral(uint256 amount) external onlyUtilizer {\\n        require(collateral!= address(0)); \\n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \\n    }\\n\\n    /// @notice can only redeem collateral when debt is fully paid \\n    function releaseAllCollateral() internal {\\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \\\"Loan status err\\\"); \\n\\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \\n    }\\n\\n\\n\\n    /// @notice should only be called when (portion of) principal is repayed\\n    function adjustInterestOwed() internal {\\n\\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\\n\\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \\n    }\\n\\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \\n    /// where area under curve is max_principal \\n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield)  external override onlyVault {\\n        principal = max_principal; \\n        notionalInterest = quoted_yield; //this accounts for duration as well\\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \\n\\n        loanStatus = LoanStatus.approvedNotDrawdowned;\\n    }\\n\\n    function onMaturity() external onlyUtilizer {\\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\\\"Not matured\\\"); \\n        require(block.number > resolveBlock, \\\"Block equal\\\"); \\n\\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid ){\\n            releaseAllCollateral(); \\n        }\\n\\n        else proxy.changeOwnership(borrower);\\n        \\n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\\n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \\n        vault.pingMaturity(address(this), isPrepaid); \\n\\n    }\\n\\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\\n    /// how much interest to repay for the current principalOwed, which can be changed \\n    function interestToRepay() public view returns(uint256){\\n\\n        // Normalized to year\\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\\n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \\n    }\\n     \\n    /// @notice Allows a borrower to borrow on their creditline.\\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\\n    /// which would start the interest timer \\n    function drawdown() external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \\\"Already borrowed\\\"); \\n        loanStatus = LoanStatus.drawdowned; \\n\\n        drawdown_block = block.timestamp; \\n        lastRepaymentTime = block.timestamp;//-31536000/2; \\n\\n        totalOwed = principal + notionalInterest; \\n        principalOwed = principal; \\n        interestOwed = notionalInterest;\\n\\n        transfer_liq(msg.sender, principal); \\n    }\\n\\n    /// @notice allows a borrower to repay their loan\\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\\n    /// whenever principal is repayed interest owed is decreased proportionally \\n    function repay( uint256 _repay_amount) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n\\n        uint256 owedInterest = interestToRepay(); \\n        uint256 repay_principal; \\n        uint256 repay_interest = _repay_amount; \\n\\n        // Push remaineder to repaying principal \\n        if (_repay_amount >= owedInterest){\\n            repay_principal += (_repay_amount - owedInterest);  \\n            repay_interest = owedInterest; \\n            accumulated_interest = 0; \\n        }\\n\\n        //else repay_amount is less than owed interest, accumulate the debt \\n        else accumulated_interest = owedInterest - repay_interest;\\n\\n        if(handleRepay(repay_principal, repay_interest)){\\n\\n            // Save resolve block, so that onMaturity can be called later\\n            resolveBlock = block.number; \\n\\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \\n\\n            // Repayed at full maturity \\n            else loanStatus = LoanStatus.matured; \\n\\n        }\\n\\n        lastRepaymentTime = getCurrentTime();  \\n\\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\\n\\n    }   \\n\\n    /// @notice updates balances after repayment\\n    /// need to remove min.\\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \\n        principalOwed -= Math.min(repay_principal, principalOwed);\\n        interestOwed -= Math.min(repay_interest, interestOwed);\\n\\n        principalRepayed += repay_principal;\\n        interestRepayed += repay_interest; \\n        if (repay_principal > 0) adjustInterestOwed(); \\n\\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \\n        return fullyRepayed; \\n    }\\n\\n    function setGracePeriod() external {}\\n\\n    /// @notice callable by anyone \\n    function beginGracePeriod() external {\\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \\\"time err\\\"); \\n        require(principalOwed > 0 && interestOwed > 0, \\\"repaid\\\"); \\n        gracePeriodStart = block.timestamp; \\n        loanStatus = LoanStatus.grace_period; \\n    }\\n\\n    function declareDefault() external onlyAuthorized {\\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\\n        require(loanStatus == LoanStatus.grace_period); \\n\\n        loanStatus = LoanStatus.isDefault; \\n    }\\n\\n    /// @notice should be called  at default by validators\\n    /// calling this function will go thorugh the necessary process\\n    /// to recoup bad debt, and will push the remaining funds to vault\\n    function onDefault() external onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n\\n        // If collateral is liquidateable, liquidate at dex and push to vault\\n        if (isLiquidatable(collateral)) {\\n            liquidateAndPushToVault(); //TODO get pool \\n        }\\n\\n        // Else for non liquid governance tokens or ownership, should auction off \\n        else {\\n            auctionAndPushToVault(); \\n        }\\n\\n        //Testing purposes only \\n        underlying.transferFrom(msg.sender, address(this), principal/2); \\n\\n    }\\n\\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\\n    function isPaymentPremature() internal returns(bool){\\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \\n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \\n\\n        // timeCondition implies amountCondition, but not the other way around \\n        return amountCondition; \\n    }\\n\\n\\n    function toYear(uint256 sec) internal pure returns(uint256){\\n        return (sec*1e18)/uint256(31536000); \\n    }\\n\\n    function toSeconds(uint256 y) internal pure returns(uint256){\\n        return uint256(31536000).mulWadDown(y); \\n    }\\n\\n    function getRemainingOwed() public view returns(uint256, uint256){\\n        return(principalOwed, interestOwed); \\n    }\\n\\n    function getCurrentLoanStatus() public view returns(uint256){}\\n\\n\\n\\n\\n\\n}\\n\\n\\ncontract Proxy{\\n    address owner; \\n    address delegator; \\n\\n    address[] public ownedContracts;\\n    mapping(address=>bytes4) public ownerTransferFunctions; \\n    mapping(address=>bool) public isValidContract; \\n\\n    /// @notice owner is first set to be the instrument contract\\n    /// and is meant to be changed back to the borrower or whoever is\\n    /// buying the ownership \\n    constructor(address _owner, address _delegator){\\n        owner = _owner; \\n        delegator = _delegator; \\n\\n    }\\n\\n    function changeOwnership(address newOwner) external {\\n        require(msg.sender == owner, \\\"Not owner\\\"); \\n        owner = newOwner; \\n    }\\n\\n    function numContracts() public view returns(uint256){\\n        return ownedContracts.length; \\n    }\\n\\n    /// @notice temporarily delegate ownership of relevant contract \\n    /// to this address, and stores the ownership transfering function\\n    /// called when initialized\\n    /// @param ownershipFunction is selector of the functions that transfers\\n    /// ownership \\n    /// @dev called by the borrower during assessment, after they had given ownership \\n    /// of the contract to this address first, \\n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \\n    /// and check that the contract is legit, and think ways that the borrower can game the system. \\n    function delegateOwnership(\\n        address _contract, \\n        bytes4 ownershipFunction) external \\n    {\\n        ownedContracts.push(_contract); \\n        isValidContract[_contract] = true; \\n        ownerTransferFunctions[_contract] = ownershipFunction; \\n\\n    }\\n\\n    /// @notice transfers ownership to borrower or any other party if necessary\\n    function grantOwnership(\\n        address _contract, \\n        address newOwner,\\n        bytes calldata data, \\n        bool isSingleArgument) external{   \\n        require(msg.sender == owner);\\n        require(isValidContract[_contract]);\\n        if(newOwner != address(this)) isValidContract[_contract] = false; \\n\\n        if(isSingleArgument){\\n            (bool success, ) = _contract.call(\\n                abi.encodeWithSelector(\\n                    ownerTransferFunctions[_contract], \\n                    newOwner\\n                )\\n            );  \\n            require(success, \\\"!success\\\"); \\n        }\\n\\n        else{\\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n            (bool success, ) = _contract.call(data);\\n            require(success, \\\"!success\\\"); \\n\\n        }\\n    }\\n\\n    /// @notice function that ownership delegators use to call functions \\n    /// in their contract other than the transferFunction contract \\n    function proxyFunc(address _contract, bytes calldata data) external{\\n        require(msg.sender == delegator); \\n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n\\n        (bool success, ) = _contract.call(data); \\n        require(success, \\\"!success\\\"); \\n\\n    }\\n\\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\\n        if (inBytes.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            outBytes4 := mload(add(inBytes, 4))\\n        }\\n    }\\n\\n    function getOwner() public view returns(address){\\n        return owner; \\n    }\\n}\\n\\n\\ncontract MockBorrowerContract{\\n\\n    address public owner; \\n    constructor(){\\n        owner = msg.sender;  \\n    }\\n\\n    function changeOwner(address newOwner) public {\\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        owner = newOwner; \\n    } \\n\\n    function onlyOwnerFunction(uint256 a) public {\\n        console.log('msgsender', msg.sender, owner); \\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        console.log('hello', a); \\n    }\\n\\n    function autoDelegate(address proxyad) public {\\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \\n    }\\n    fallback () external {\\n        console.log('hi?'); \\n    }\\n}\\n\",\"keccak256\":\"0x6bf91799acffcac25c82b2d290c4632a3574d46d68402f5f763db87bae8118db\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n// import {ERC20} from \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    uint immutable underlying_decimals; \\n    uint8 constant default_decimals = 18; \\n    bool public decimal_mismatch; \\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, default_decimals) {\\n        asset = _asset;\\n\\n        underlying_decimals = _asset.decimals(); \\n        decimal_mismatch = (_asset.decimals() != default_decimals);\\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function burn(uint256 shares) public virtual {\\n        _burn(msg.sender, shares);\\n    }\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n\\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\\n        return assets * (10 ** (default_decimals - underlying_decimals)); \\n    }\\n\\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\\n        return shares / (10**(default_decimals - underlying_decimals)); \\n    }\\n}\\n\",\"keccak256\":\"0xe3819a59ee062bb8a99e9ddddbdf15e3cef2e6eb3068072309d9d189243af5ff\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0x636e0f18c1b287c9342e14660a914b37a927d9f64d6c29e27016784979ce8d59\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/vault.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {Auth} from \\\"./auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"./mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"./utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"./instrument.sol\\\";\\nimport {Controller} from \\\"../protocol/controller.sol\\\";\\nimport {MarketManager} from \\\"../protocol/marketmanager.sol\\\"; \\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\ncontract Vault is ERC4626, Auth{\\n    using SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal BASE_UNIT;\\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\\n    ERC20 public immutable UNDERLYING;\\n    Controller private controller;\\n    MarketManager.MarketParameters default_params; \\n\\n    ///// For Factory\\n    bool public onlyVerified; \\n    uint256 public r; //reputation ranking  \\n    uint256 public asset_limit; \\n    uint256 public total_asset_limit; \\n\\n    mapping(Instrument => InstrumentData) public instrument_data;\\n    mapping(address => uint256) public  num_proposals;\\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\\n    mapping(uint256 => bool) resolveBeforeMaturity;\\n    mapping(uint256=>ResolveVar) prepareResolveBlock;\\n\\n    enum InstrumentType {\\n        CreditLine,\\n        CoveredCall,\\n        Pool, \\n        Other\\n    }\\n\\n\\n    /// @param trusted Whether the Instrument is trusted.\\n    /// @param balance The amount of underlying tokens held in the Instrument.\\n    struct InstrumentData {\\n      bytes32 name;\\n      bool isPool; \\n      // Used to determine if the Vault will operate on a Instrument.\\n      bool trusted;\\n      // Balance of the contract denominated in Underlying, \\n      // used to determine profit and loss during harvests of the Instrument.  \\n      // represents the amount of debt the Instrument has incurred from this vault   \\n      uint256 balance; // in underlying, IMPORTANT to get this number right as it modifies key states \\n      uint256 faceValue; // in underlying\\n      uint256 marketId;\\n      uint256 principal; //this is total available allowance in underlying\\n      uint256 expectedYield; // total interest paid over duration in underlying\\n      uint256 duration;\\n      string description;\\n      address instrument_address;\\n      InstrumentType instrument_type;\\n      uint256 maturityDate;\\n      PoolData poolData; \\n    }\\n\\n    /// @notice probably should have default parameters for each vault\\n    struct PoolData{\\n      uint256 saleAmount; \\n      uint256 initPrice; // init price of longZCB in the amm \\n      uint256 promisedReturn; //per unit time \\n      uint256 inceptionTime;\\n      uint256 inceptionPrice; // init price of longZCB after assessment \\n      uint256 leverageFactor; //leverageFactor * manager collateral = capital from vault to instrument\\n      uint256 managementFee; // sum of discounts for high reputation managers/validators \\n    }\\n\\n    struct ResolveVar{\\n        uint256 endBlock; \\n        bool isPrepared; \\n    }\\n\\n    constructor(\\n        address _UNDERLYING,\\n        address _controller, \\n        address owner, \\n\\n        bool _onlyVerified, //\\n        uint256 _r, //reputation ranking\\n        uint256 _asset_limit, \\n        uint256 _total_asset_limit,\\n\\n        MarketManager.MarketParameters memory _default_params\\n    )\\n        ERC4626(\\n            ERC20(_UNDERLYING),\\n            string(abi.encodePacked(\\\"debita \\\", ERC20(_UNDERLYING).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"db\\\", ERC20(_UNDERLYING).symbol()))\\n        )  Auth(owner)\\n\\n    {\\n        UNDERLYING = ERC20(_UNDERLYING);\\n        BASE_UNIT = 10**18; \\n        controller = Controller(_controller);\\n        set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \\n        default_params = _default_params; \\n    }\\n\\n    function getInstrumentType(uint256 marketId) public view returns(uint256){\\n        // return 0 if credit line //TODO \\n        return 0; \\n    }\\n\\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\\n        return instrument_data[_instrument];\\n    }\\n    \\n    modifier onlyController(){\\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \\\"is not controller\\\"); \\n        _;\\n    }\\n\\n    /// @notice called by controller at maturity \\n    function controller_burn(uint256 amount, address bc_address) external onlyController {\\n        _burn(bc_address,amount); \\n    }\\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\\n    function controller_mint(uint256 amount, address to) external onlyController {\\n        _mint(to , amount); \\n    }\\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\\n    function trusted_transfer(uint256 amount, address to) external onlyController{\\n        if (decimal_mismatch) amount = decSharesToAssets(amount); \\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    function balanceInUnderlying(address ad) external view returns(uint256){\\n        return previewRedeem(balanceOf[ad]); \\n    }\\n\\n    /// @notice burns all balance of address \\n    function burnAll(address to) private{\\n      _burn(to, balanceOf[to]); \\n    }\\n\\n  struct localVars{\\n    uint256 promised_return; \\n    uint256 inceptionTime; \\n    uint256 inceptionPrice; \\n    uint256 leverageFactor; \\n    uint256 managementFee; \\n\\n    uint256 srpPlusOne; \\n    uint256 totalAssetsHeld; \\n    uint256 juniorSupply; \\n    uint256 seniorSupply; \\n\\n    bool belowThreshold; \\n  }\\n  /// @notice get programmatic pricing of a pool based longZCB \\n  /// returns psu: price of senior(VT's share of investment) vs underlying \\n  /// returns pju: price of junior(longZCB) vs underlying\\n  function poolZCBValue(uint256 marketId) \\n    public \\n    view \\n    returns(uint256 psu, uint256 pju, uint256 levFactor){\\n    localVars memory vars; \\n\\n    (vars.promised_return, vars.inceptionTime, vars.inceptionPrice, vars.leverageFactor, \\n      vars.managementFee) = fetchPoolTrancheData(marketId); \\n    levFactor = vars.leverageFactor; \\n\\n    require(vars.inceptionPrice > 0, \\\"0\\\"); \\n\\n    // Get senior redemption price that increments per unit time \\n    vars.srpPlusOne = vars.inceptionPrice.mulWadDown((BASE_UNIT+ vars.promised_return)\\n      .rpow(block.timestamp - vars.inceptionTime, BASE_UNIT));\\n\\n    // Get total assets held by the instrument \\n    vars.totalAssetsHeld = instrumentAssetOracle(marketId); \\n    vars.juniorSupply = controller.getTotalSupply(marketId); \\n    vars.seniorSupply = vars.juniorSupply.mulWadDown(vars.leverageFactor); \\n    if (vars.seniorSupply == 0) return(vars.srpPlusOne,vars.srpPlusOne,levFactor); \\n    \\n    // Check if all seniors can redeem\\n    if (vars.totalAssetsHeld >= vars.srpPlusOne.mulWadDown(vars.seniorSupply))\\n      psu = vars.srpPlusOne; \\n    else{\\n      psu = vars.totalAssetsHeld.divWadDown(vars.seniorSupply);\\n      vars.belowThreshold = true;  \\n    }\\n\\n    // should be 0 otherwise \\n    if(!vars.belowThreshold) pju = (vars.totalAssetsHeld \\n      - vars.srpPlusOne.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \\n    }\\n\\n    /// @notice Harvest a trusted Instrument, records profit/loss \\n    function harvest(address instrument) public {\\n      require(instrument_data[Instrument(instrument)].trusted, \\\"UNTRUSTED_Instrument\\\");\\n      InstrumentData storage data = instrument_data[Instrument(instrument)]; \\n\\n      uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \\n      uint256 balanceLastHarvest = data.balance;\\n      uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\\n      \\n      if (balanceLastHarvest == balanceThisHarvest) {\\n          return;\\n      }\\n\\n      data.balance = balanceThisHarvest;\\n\\n      uint256 delta;\\n      bool net_positive = balanceThisHarvest >= balanceLastHarvest;\\n      delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\\n      totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\\n\\n      emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\\n    }\\n\\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\\n    /// Called when market is approved. \\n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \\n    function depositIntoInstrument(uint256 marketId, uint256 underlyingAmount) public \\n  //onlyManager\\n    {\\n      Instrument instrument = fetchInstrument(marketId); \\n      require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n\\n      if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      if (underlyingAmount > UNDERLYING.balanceOf(address(this))) revert(\\\"Not enough bal in vault\\\"); \\n\\n      totalInstrumentHoldings += underlyingAmount; \\n\\n      instrument_data[instrument].balance += underlyingAmount;\\n\\n      require(UNDERLYING.transfer(address(instrument), underlyingAmount), \\\"DEPOSIT_FAILED\\\");\\n\\n      emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) internal {\\n      require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n      \\n      if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      instrument_data[instrument].balance -= underlyingAmount;\\n      \\n      totalInstrumentHoldings -= underlyingAmount;\\n      \\n      require(instrument.redeemUnderlying(underlyingAmount), \\\"REDEEM_FAILED\\\");\\n      \\n      emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\\n    }\\n\\n    function withdrawFromInstrumentExternal(\\n      uint256 marketId, \\n      uint256 underlyingAmount\\n      ) external\\n    //onlyManager\\n    {\\n      require(fetchInstrument( marketId).isLiquid(underlyingAmount), \\\"!liq\\\"); \\n      withdrawFromInstrument(fetchInstrument(marketId), underlyingAmount);\\n    }\\n    /// @notice Stores a Instrument as trusted when its approved\\n    function trustInstrument(\\n      uint256 marketId,\\n      Controller.ApprovalData memory data, \\n      bool isPool\\n      ) external onlyController{\\n      instrument_data[fetchInstrument(marketId)].trusted = true;\\n\\n      //Write to storage \\n      if(!isPool){\\n        InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \\n        instrumentData.principal = data.approved_principal; \\n        instrumentData.expectedYield = data.approved_yield;\\n        instrumentData.faceValue = data.approved_principal + data.approved_yield; \\n\\n        depositIntoInstrument(marketId, data.approved_principal);\\n        \\n        setMaturityDate(marketId);\\n\\n        fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \\n\\n      } else{\\n        depositIntoInstrument(marketId, data.approved_principal);\\n      }\\n    }\\n\\n    /// @notice fetches how much asset the instrument has in underlying. \\n    function instrumentAssetOracle(uint256 marketId) public view returns(uint256){\\n      // Default balance oracle \\n      return instrument_data[Instruments[marketId]].balance; \\n      //TODO custom oracle \\n    }\\n\\n    /// @notice Stores a Instrument as untrusted\\n    function distrustInstrument(Instrument instrument) external onlyController {\\n      instrument_data[instrument].trusted = false; \\n    }\\n\\n    /// @notice returns true if Instrument is approved\\n    function isTrusted(Instrument instrument) public view returns(bool){\\n      return instrument_data[instrument].trusted; \\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \\n    function totalAssets() public view override returns(uint256){\\n      return totalInstrumentHoldings + totalFloat();\\n    }\\n\\n    function utilizationRate() public view returns(uint256){\\n\\n        if (totalInstrumentHoldings==0) return 0;  \\n        return totalInstrumentHoldings.divWadDown(totalAssets()); \\n\\n    }\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\\n      return Instruments[marketId]; \\n    }\\n\\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\\n      return instrument_data[Instruments[marketId]];\\n    }\\n\\n    function fetchPoolTrancheData(uint256 marketId) public view returns(uint256, uint256, uint256, uint256, uint256){\\n      InstrumentData memory data = instrument_data[Instruments[marketId]]; \\n      return (data.poolData.promisedReturn, data.poolData.inceptionTime, \\n            data.poolData.inceptionPrice, data.poolData.leverageFactor, data.poolData.managementFee); \\n    }\\n\\n    /**\\n     called on market denial + removal, maybe no chekcs?\\n     */\\n    function removeInstrument(uint256 marketId) internal {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n        require(data.marketId > 0, \\\"instrument doesn't exist\\\");\\n        delete instrument_data[Instruments[marketId]];\\n        delete Instruments[marketId];\\n        // emit event here;\\n    }\\n\\n    /// @notice add instrument proposal created by the Utilizer \\n    /// @dev Instrument instance should be created before this is called\\n    /// need to add authorization\\n    function addProposal(\\n        InstrumentData memory data\\n    ) external onlyController {\\n      if(!data.isPool){\\n        require(data.principal > 0, \\\"principal must be greater than 0\\\");\\n        require(data.duration > 0, \\\"duration must be greater than 0\\\");\\n        require(data.faceValue > 0, \\\"faceValue must be greater than 0\\\");\\n        require(data.principal >= BASE_UNIT, \\\"Needs to be in decimal format\\\"); \\n        require(data.marketId > 0, \\\"must be valid instrument\\\");\\n      }\\n        num_proposals[msg.sender] ++; \\n\\n        instrument_data[Instrument(data.instrument_address)] = data;  \\n\\n        Instruments[data.marketId] = Instrument(data.instrument_address);\\n    }\\n\\n    function setMaturityDate(uint256 marketId) internal {\\n\\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\\n    }\\n\\n    /// @notice function called when instrument resolves from within\\n    function pingMaturity(address instrument, bool premature) external {\\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \\n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \\n        beforeResolve(marketId); \\n        resolveBeforeMaturity[marketId] = premature; \\n    }\\n\\n    /// @notice RESOLVE FUNCTION #1\\n    /// Checks if instrument is ready to be resolved and locks capital.\\n    /// records blocknumber such that resolveInstrument is called after this function \\n    /// records balances+PnL of instrument\\n    /// @dev need to store internal balance that is used to calculate the redemption price \\n    function beforeResolve(uint256 marketId) public {\\n        Instrument _instrument = Instruments[marketId]; \\n\\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \\\"Not allowed\\\"); \\n        require(isTrusted( _instrument), \\\"Not trusted\\\"); \\n\\n        // Should revert if can't be resolved \\n        _instrument.prepareWithdraw();\\n\\n        // Record profit/loss used for calculation of redemption price \\n        harvest(address(_instrument));\\n\\n        _instrument.store_internal_balance(); \\n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \\n      }\\n\\n    /// @notice RESOLVE FUNCTION #2\\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \\n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\\n    function resolveInstrument(\\n        uint256 marketId\\n    ) external onlyController\\n    returns(bool, uint256, uint256, bool) {\\n        Instrument _instrument = Instruments[marketId];\\n        ResolveVar memory rvar = prepareResolveBlock[marketId]; \\n        require(_instrument.isLocked(), \\\"Not Locked\\\");\\n        require(rvar.isPrepared && rvar.endBlock < block.number, \\\"can't resolve\\\"); \\n\\n        uint256 bal = UNDERLYING.balanceOf(address(this)); \\n        uint256 instrument_balance = _instrument.getMaturityBalance(); \\n\\n        InstrumentData memory data = instrument_data[_instrument];\\n\\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \\n        bool atLoss; \\n        uint256 total_loss; \\n        uint256 extra_gain; \\n\\n        // If resolved at predetermined maturity date, loss is defined by\\n        // the event the instrument has paid out all its yield + principal \\n        if (!prematureResolve){\\n            atLoss = instrument_balance < data.faceValue;\\n            total_loss = atLoss ? data.faceValue - instrument_balance : 0;\\n            extra_gain = !atLoss ? instrument_balance - data.faceValue : 0;\\n        }\\n\\n        // If resolved before predetermined maturity date, loss is defined by \\n        // the event the instrument has balance less then principal \\n        else {\\n            atLoss = instrument_balance < data.principal; \\n            total_loss = atLoss? data.principal - instrument_balance :0; \\n        }\\n\\n        withdrawFromInstrument(_instrument, instrument_balance);\\n        removeInstrument(data.marketId);\\n\\n        return(atLoss, extra_gain, total_loss, prematureResolve); \\n    }\\n\\n    /// @notice when market resolves, send back pulled collateral from managers \\n    function repayDebt(address to, uint256 amount) external onlyController{\\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    /**\\n     called on market denial by controller.\\n     */\\n    function denyInstrument(uint256 marketId) external onlyController {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n\\n        require(marketId > 0 && data.instrument_address != address(0), \\\"invalid instrument\\\");\\n\\n        require(!data.trusted, \\\"can't deny approved instrument\\\");\\n        \\n        removeInstrument(marketId);\\n    }\\n\\n\\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\\n      return Instruments[marketId].instrumentApprovalCondition(); \\n    }\\n\\n    /// TODO \\n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\\n      return amount; \\n    }\\n\\n\\n    /// @notice types of restrictions are: \\n    /// a) verified address b) reputation scores \\n    function receiver_conditions(address receiver) public view returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice called when constructed, params set by the creater of the vault \\n    function set_minting_conditions(\\n      bool _onlyVerified, \\n      uint256 _r, \\n      uint256 _asset_limit,\\n      uint256 _total_asset_limit) internal{\\n        onlyVerified = _onlyVerified; \\n        r = _r; \\n        asset_limit = _asset_limit; \\n        total_asset_limit = _total_asset_limit; \\n    } \\n\\n\\n    function get_vault_params() public view returns(MarketManager.MarketParameters memory){\\n      return default_params; \\n    }\\n\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\\n      require(enoughLiqudity(assets), \\\"Not enough liqudity in vault\\\"); \\n\\n    }\\n\\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\\n    /// (excluding those supplied to existing instruments)\\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\\n    /// should be (soft)maxed and tunable by a parameter \\n    function enoughLiqudity(uint256 amounts) public view returns(bool){\\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \\n    }\\n\\n\\n    /// @notice function that closes instrument prematurely \\n    function closeInstrument(uint256 marketId) external onlyController{\\n      Instrument instrument = fetchInstrument( marketId); \\n\\n      // If instrument has non-underlying tokens, liquidate them first. \\n      instrument.liquidateAllPositions(); \\n\\n    }\\n\\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\\n        InstrumentData memory data = instrument_data[Instruments[marketId]];\\n        return (data.principal, data.expectedYield); \\n    }\\n\\n    /// @notice a minting restrictor is set for different vaults \\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\\n        if (!receiver_conditions(receiver)) revert(\\\"Minting Restricted\\\"); \\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n\\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \\n     function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        assets = deduct_withdrawal_fees(assets); \\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n\\n\\n\\n}\",\"keccak256\":\"0x765390fce522a8d45c2dc3931ee28779866129fc689d6f996be43037e12147ff\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xbaa90c891304799f6aa4039eae4b59afc0b59ce3bcc647f3fc2bbf5a04b17f1e\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x768fcac57789d8edb0b4c8e02bad17b15faeebbc3c8b2c8ec473b485cc0b59fe\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"lib/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab8ca9afbb0f7412e1408d4f111b53cc00813bc752236638ad336050ea2188f8\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051615dc4380380615dc483398101604081905261002f91610062565b60008054336001600160a01b031991821617909155600380549091166001600160a01b0392909216919091179055610092565b60006020828403121561007457600080fd5b81516001600160a01b038116811461008b57600080fd5b9392505050565b615d23806100a16000396000f3fe60806040523480156200001157600080fd5b5060043610620000465760003560e01c8063264a6208146200004b578063652b9b411462000068578063da33133314620000a8575b600080fd5b6200005560025481565b6040519081526020015b60405180910390f35b62000097620000793660046200030a565b6001600160a01b031660009081526001602052604090205460ff1690565b60405190151581526020016200005f565b620000bf620000b93660046200032f565b620000df565b604080516001600160a01b0390931683526020830191909152016200005f565b60035460009081906001600160a01b03163314806200010857506000546001600160a01b031633145b806200011357503330145b620001595760405162461bcd60e51b815260206004820152601160248201527034b9903737ba1031b7b73a3937b63632b960791b60448201526064015b60405180910390fd5b662386f26fc1000083604001511015620001a85760405162461bcd60e51b815260206004820152600f60248201526e105b1c1a18481d1bdbc81cdb585b1b608a1b604482015260640162000150565b6000898960008054906101000a90046001600160a01b03168a8a8a8a8a604051620001d390620002df565b6001600160a01b0398891681529688166020808901919091529590971660408088019190915293151560608088019190915260808088019490945260a08088019390935260c080880192909252875160e0808901919091529588015161010088015284880151610120880152870151610140870152918601516101608601528501516101808501528401516101a08401529201516101c08201529051908190036101e001906000f0801580156200028e573d6000803e3d6000fd5b506001600160a01b03811660009081526001602081905260408220805460ff191690911790556002805492935090620002c78362000444565b9091555050600254909a909950975050505050505050565b61587f806200046f83390190565b80356001600160a01b03811681146200030557600080fd5b919050565b6000602082840312156200031d57600080fd5b6200032882620002ed565b9392505050565b60008060008060008060008789036101c08112156200034d57600080fd5b6200035889620002ed565b97506200036860208a01620002ed565b9650604089013580151581146200037e57600080fd5b9550606089013594506080890135935060a0890135925061010060bf198201811315620003aa57600080fd5b604051915080820182811067ffffffffffffffff82111715620003dd57634e487b7160e01b600052604160045260246000fd5b806040525060c08a0135825260e08a01356020830152808a01356040830152506101208901356060820152610140890135608082015261016089013560a082015261018089013560c08201526101a089013560e08201528091505092959891949750929550565b60006000198214156200046757634e487b7160e01b600052601160045260246000fd5b506001019056fe6101406040523480156200001257600080fd5b506040516200587f3803806200587f8339810160408190526200003591620005ab565b8588896001600160a01b03166306fdde036040518163ffffffff1660e01b8152600401600060405180830381865afa15801562000076573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052620000a09190810190620006dc565b604051602001620000b2919062000794565b6040516020818303038152906040528a6001600160a01b03166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa15801562000100573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526200012a9190810190620006dc565b6040516020016200013c9190620007d5565b60405160208183030381529060405281816012826000908051906020019062000167929190620004a6565b5081516200017d906001906020850190620004a6565b5060ff81166080524660a052620001936200040a565b60c0525050506001600160a01b03831660e08190526040805163313ce56760e01b8152905163313ce567916004808201926020929091908290030181865afa158015620001e4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020a919062000801565b60ff166101008181525050601260ff16836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000259573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200027f919062000801565b6006805460ff191660ff9283169390931415928317905516156200031a57601260ff16836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015620002e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000307919062000801565b60ff16106200031a576200031a6200082d565b505060068054610100600160a81b0319166101006001600160a01b0385169081029190911790915560405190915033907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7690600090a3506001600160a01b0388811661012052670de0b6b3a7640000600955600b80546001600160a01b0319169189169190911790556014805460ff19168615151790556015849055601683905560178290558051600c556020810151600d556040810151600e556060810151600f55608081015160105560a081015160115560c081015160125560e00151601355506200092495505050505050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60006040516200043e919062000880565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b828054620004b49062000843565b90600052602060002090601f016020900481019282620004d8576000855562000523565b82601f10620004f357805160ff191683800117855562000523565b8280016001018555821562000523579182015b828111156200052357825182559160200191906001019062000506565b506200053192915062000535565b5090565b5b8082111562000531576000815560010162000536565b80516001600160a01b03811681146200056457600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b0381118282101715620005a557620005a562000569565b60405290565b600080600080600080600080888a036101e0811215620005ca57600080fd5b620005d58a6200054c565b9850620005e560208b016200054c565b9750620005f560408b016200054c565b965060608a015180151581146200060b57600080fd5b8096505060808a0151945060a08a0151935060c08a015192506101008060df19830112156200063957600080fd5b620006436200057f565b915060e08b01518252808b01516020830152506101208a015160408201526101408a015160608201526101608a015160808201526101808a015160a08201526101a08a015160c08201526101c08a015160e0820152809150509295985092959890939650565b60005b83811015620006c6578181015183820152602001620006ac565b83811115620006d6576000848401525b50505050565b600060208284031215620006ef57600080fd5b81516001600160401b03808211156200070757600080fd5b818401915084601f8301126200071c57600080fd5b81518181111562000731576200073162000569565b604051601f8201601f19908116603f011681019083821181831017156200075c576200075c62000569565b816040528281528760208487010111156200077657600080fd5b62000789836020830160208801620006a9565b979650505050505050565b6603232b134ba30960cd1b815260008251620007b8816007850160208701620006a9565b650815985d5b1d60d21b6007939091019283015250600d01919050565b61323160f11b815260008251620007f4816002850160208701620006a9565b9190910160020192915050565b6000602082840312156200081457600080fd5b815160ff811681146200082657600080fd5b9392505050565b634e487b7160e01b600052600160045260246000fd5b600181811c908216806200085857607f821691505b602082108114156200087a57634e487b7160e01b600052602260045260246000fd5b50919050565b600080835481600182811c9150808316806200089d57607f831692505b6020808410821415620008be57634e487b7160e01b86526022600452602486fd5b818015620008d55760018114620008e75762000916565b60ff1986168952848901965062000916565b60008a81526020902060005b868110156200090e5781548b820152908501908301620008f3565b505084890196505b509498975050505050505050565b60805160a05160c05160e0516101005161012051614eb7620009c8600039600081816109e20152818161116701528181612078015281816121f00152818161290f01528181612a3e0152818161362c0152613a9a01526000818161110a015261230601526000818161063701528181611ef00152818161227d01528181612ca60152612def015260006117b601526000611786015260006105f60152614eb76000f3fe608060405234801561001057600080fd5b50600436106104545760003560e01c80637ecebe0011610241578063c5d664c61161013b578063dc361a13116100c3578063edb53d3e11610087578063edb53d3e14610b4c578063ef8b30f714610b5f578063f05bcfb414610b72578063f7d070de14610b85578063fc173fc614610b9257600080fd5b8063dc361a1314610ab0578063dd62ed3e14610ac3578063e134cc8214610aee578063e3fac5bf14610b25578063e9a23d3a14610b3857600080fd5b8063ca13e4501161010a578063ca13e45014610a20578063ce96cb7714610a4e578063d505accf14610a61578063d746d3ef14610a74578063d905777e14610a8757600080fd5b8063c5d664c6146109dd578063c63d75b614610671578063c6e6f59214610a04578063c83baf4e14610a1757600080fd5b80639ec4d40e116101c9578063b3d7f6b91161018d578063b3d7f6b91461097e578063b460af9414610991578063ba087652146109a4578063bebf7a04146109b7578063bf7e214f146109ca57600080fd5b80639ec4d40e146108f9578063a9059cbb1461090c578063ab0c79d01461091f578063ab0fd37e14610932578063b19b1f911461096b57600080fd5b806395d89b411161021057806395d89b41146108a557806396ce9d5a146108ad57806396d64879146108c057806398d796e7146108d35780639d0eba61146108e657600080fd5b80637ecebe0014610852578063841219e5146108725780638da5cb5b1461087a57806394bf804d1461089257600080fd5b806338d52e0f1161035257806360d4efa4116102da5780636e553f651161029e5780636e553f651461079057806370a08231146107a35780637572cb1f146107c357806379e20bdc1461082c5780637a9e5e4b1461083f57600080fd5b806360d4efa414610724578063692eba091461074c5780636a9f1bdb1461076c5780636c321c8a1461077f5780636c8ae38c1461078757600080fd5b80634cdad506116103215780634cdad506146106ac5780634dc54a38146106bf57806350c6e6cf146106df57806359dc5c6f146107085780635f260bb81461071b57600080fd5b806338d52e0f14610632578063402d267d1461067157806342966c6814610686578063471e1cea1461069957600080fd5b8063139f4b6f116103e057806322f0e069116103a457806322f0e0691461059e57806323b872dd146105cb5780632b858734146105de578063313ce567146105f15780633644e5151461062a57600080fd5b8063139f4b6f1461054957806313af40351461055c57806316f6cb071461056f57806318160ddd14610582578063213a7d521461058b57600080fd5b8063095ea7b311610427578063095ea7b3146104d75780630a28a477146104fa5780630e5c011e1461050d5780630f65cbc4146105225780631316dbde1461053657600080fd5b806301e1d1141461045957806306fdde0314610474578063076125a91461048957806307a2d13a146104c4575b600080fd5b610461610b9f565b6040519081526020015b60405180910390f35b61047c610bbb565b60405161046b919061441b565b61049c61049736600461442e565b610c49565b604080519586526020860194909452928401919091526060830152608082015260a00161046b565b6104616104d236600461442e565b610e75565b6104ea6104e536600461446c565b610eb9565b604051901515815260200161046b565b61046161050836600461442e565b610f26565b61052061051b366004614498565b610f5f565b005b61046161053036600461442e565b50600090565b61046161054436600461442e565b611103565b6104ea61055736600461442e565b611145565b61052061056a366004614498565b6111da565b61052061057d3660046144b5565b61127f565b61046160025481565b6105206105993660046144f0565b611341565b6105b16105ac366004614498565b6113aa565b60405161046b9e9d9c9b9a999897969594939291906145a5565b6104ea6105d936600461463e565b6114f3565b6105206105ec36600461442e565b6115d3565b6106187f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff909116815260200161046b565b610461611782565b6106597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161046b565b61046161067f366004614498565b5060001990565b61052061069436600461442e565b6117d8565b6104ea6106a736600461442e565b6117e5565b6104616106ba36600461442e565b61185b565b6106d26106cd366004614498565b611866565b60405161046b919061467f565b6106596106ed36600461442e565b601a602052600090815260409020546001600160a01b031681565b61052061071636600461442e565b611a40565b61046160165481565b61073761073236600461442e565b611b04565b6040805192835260208301919091520161046b565b61046161075a366004614498565b60196020526000908152604090205481565b61052061077a3660046147a3565b611cfb565b610461611e74565b61046160155481565b61046161079e366004614823565b611e9b565b6104616107b1366004614498565b60036020526000908152604090205481565b6107cb611f6e565b60405161046b9190600061010082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b61052061083a36600461446c565b612004565b61052061084d366004614498565b6120e6565b610461610860366004614498565b60056020526000908152604090205481565b6104616121d8565b6006546106599061010090046001600160a01b031681565b6104616108a0366004614823565b612263565b61047c6122f2565b6104616108bb36600461442e565b6122ff565b6104ea6108ce366004614498565b612341565b6105206108e1366004614968565b612367565b6105206108f4366004614498565b612714565b6106d261090736600461442e565b612754565b6104ea61091a36600461446c565b612808565b61052061092d3660046144b5565b61286e565b61046161094036600461442e565b6000908152601a60209081526040808320546001600160a01b03168352601890915290206002015490565b610520610979366004614498565b612b2d565b61046161098c36600461442e565b612ba0565b61046161099f366004614a8e565b612bbf565b6104616109b2366004614a8e565b612ccd565b6105206109c5366004614823565b612e16565b600754610659906001600160a01b031681565b6106597f000000000000000000000000000000000000000000000000000000000000000081565b610461610a1236600461442e565b612e6e565b61046160175481565b610a33610a2e36600461442e565b612e8e565b6040805193845260208401929092529082015260600161046b565b610461610a5c366004614498565b6130e2565b610520610a6f366004614ac5565b613104565b610520610a8236600461442e565b613348565b610461610a95366004614498565b6001600160a01b031660009081526003602052604090205490565b610461610abe366004614498565b613479565b610461610ad1366004614b3c565b600460209081526000928352604080842090915290825290205481565b610b01610afc36600461442e565b61349b565b6040805194151585526020850193909352918301521515606082015260800161046b565b610520610b33366004614823565b613991565b6104ea610b46366004614498565b50600190565b610659610b5a36600461442e565b6139e9565b610461610b6d36600461442e565b613a04565b610520610b80366004614823565b613a0f565b6014546104ea9060ff1681565b6006546104ea9060ff1681565b6000610ba96121d8565b600a54610bb69190614b80565b905090565b60008054610bc890614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054610bf490614b98565b8015610c415780601f10610c1657610100808354040283529160200191610c41565b820191906000526020600020905b815481529060010190602001808311610c2457829003601f168201915b505050505081565b6000818152601a60209081526040808320546001600160a01b031683526018825280832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e08301526007810154928201929092526008820180548493849384938493849391610120840191610cfe90614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054610d2a90614b98565b8015610d775780601f10610d4c57610100808354040283529160200191610d77565b820191906000526020600020905b815481529060010190602001808311610d5a57829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff166003811115610db457610db4614529565b6003811115610dc557610dc5614529565b8152602001600a8201548152602001600b82016040518060e0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815260200160058201548152602001600682015481525050815250509050806101a0015160400151816101a0015160600151826101a0015160800151836101a0015160a00151846101a0015160c00151955095509550955095505091939590929450565b6002546000908015610e9957610e94610e8c610b9f565b849083613ac9565b610eb2565b60065460ff16610ea95782610eb2565b610eb283611103565b9392505050565b3360008181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590610f149086815260200190565b60405180910390a35060015b92915050565b6002546000908015610f4657610e9481610f3e610b9f565b859190613ae8565b60065460ff16610f565782610eb2565b610eb2836122ff565b6001600160a01b038116600090815260186020526040902060010154610100900460ff16610fcb5760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115117d25b9cdd1c9d5b595b9d60621b60448201526064015b60405180910390fd5b6001600160a01b038116600081815260186020526040808220600a5460028201549251633af9e66960e01b8152600481018690529194909391633af9e66990602401602060405180830381865afa15801561102a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104e9190614bd3565b90508082141561105f575050505050565b60028401819055600082821015806110805761107b8385614bec565b61108a565b61108a8484614bec565b9150806110a05761109b8286614bec565b6110aa565b6110aa8286614b80565b600a5560408051848152602081018490528215158183015290516001600160a01b038916917f633a7d7c82bd537c647d654b96128a9b02a675bd73abe910b82f875ce4776391919081900360600190a250505050505050565b60006111307f00000000000000000000000000000000000000000000000000000000000000006012614bec565b61113b90600a614ce7565b610f209083614cf3565b6040516370a0823160e01b815230600482015260009082906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa1580156111ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d29190614bd3565b101592915050565b6111f0336000356001600160e01b031916613b16565b61122b5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610fc2565b60068054610100600160a81b0319166101006001600160a01b0384169081029190911790915560405133907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7690600090a350565b611288826139e9565b6001600160a01b031663537d9409826040518263ffffffff1660e01b81526004016112b591815260200190565b602060405180830381865afa1580156112d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112f69190614d15565b61132b5760405162461bcd60e51b8152600401610fc290602080825260049082015263216c697160e01b604082015260600190565b61133d611337836139e9565b82613b55565b5050565b336001600160a01b038316148061135c575061135c82612341565b61136557600080fd5b6001600160a01b03821660009081526018602052604090206004015461138a816115d3565b6000908152601b60205260409020805460ff191691151591909117905550565b601860205260009081526040902080546001820154600283015460038401546004850154600586015460068701546007880154600889018054989960ff808a169a610100909a0416989091906113ff90614b98565b80601f016020809104026020016040519081016040528092919081815260200182805461142b90614b98565b80156114785780601f1061144d57610100808354040283529160200191611478565b820191906000526020600020905b81548152906001019060200180831161145b57829003601f168201915b505050506009830154600a8401546040805160e081018252600b8701548152600c8701546020820152600d87015491810191909152600e8601546060820152600f8601546080820152601086015460a082015260119095015460c086015292936001600160a01b03821693600160a01b90920460ff1692508e565b6001600160a01b0383166000908152600460209081526040808320338452909152812054600019811461154f5761152a8382614bec565b6001600160a01b03861660009081526004602090815260408083203384529091529020555b6001600160a01b03851660009081526003602052604081208054859290611577908490614bec565b90915550506001600160a01b0380851660008181526003602052604090819020805487019055519091871690600080516020614e62833981519152906115c09087815260200190565b60405180910390a3506001949350505050565b6000818152601a60205260409020546001600160a01b0316338114806116035750600b546001600160a01b031633145b61163d5760405162461bcd60e51b815260206004820152600b60248201526a139bdd08185b1b1bddd95960aa1b6044820152606401610fc2565b61164681612341565b6116805760405162461bcd60e51b815260206004820152600b60248201526a139bdd081d1c9d5cdd195960aa1b6044820152606401610fc2565b806001600160a01b03166349dcf4ed6040518163ffffffff1660e01b81526004016060604051808303816000875af11580156116c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116e49190614d32565b5050506116f081610f5f565b806001600160a01b031663f3aa68d36040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561172b57600080fd5b505af115801561173f573d6000803e3d6000fd5b5050604080518082018252438152600160208083018281526000988952601c909152929096209051815590519401805460ff191694151594909417909355505050565b60007f000000000000000000000000000000000000000000000000000000000000000046146117b357610bb6613d08565b507f000000000000000000000000000000000000000000000000000000000000000090565b6117e23382613da2565b50565b6000818152601a6020908152604080832054815163041f3aa560e51b815291516001600160a01b03909116926383e754a092600480820193918290030181865afa158015611837573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f209190614d15565b6000610f2082610e75565b61186e614250565b6001600160a01b03821660009081526018602090815260409182902082516101c08101845281548152600182015460ff808216151594830194909452610100908190049093161515938101939093526002810154606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e08401526007810154918301919091526008810180546101208401919061191190614b98565b80601f016020809104026020016040519081016040528092919081815260200182805461193d90614b98565b801561198a5780601f1061195f5761010080835404028352916020019161198a565b820191906000526020600020905b81548152906001019060200180831161196d57829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff1660038111156119c7576119c7614529565b60038111156119d8576119d8614529565b8152600a8201546020808301919091526040805160e081018252600b8501548152600c85015492810192909252600d84015482820152600e8401546060830152600f8401546080830152601084015460a083015260119093015460c082015291015292915050565b600b546001600160a01b0316331480611a68575060065461010090046001600160a01b031633145b80611a7257503033145b611a8e5760405162461bcd60e51b8152600401610fc290614d60565b6000611a99826139e9565b9050806001600160a01b03166350bb4beb6040518163ffffffff1660e01b81526004016020604051808303816000875af1158015611adb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aff9190614bd3565b505050565b6000818152601a60209081526040808320546001600160a01b031683526018825280832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e08301526007810154928201929092526008820180548493849392909161012084019190611bb690614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054611be290614b98565b8015611c2f5780601f10611c0457610100808354040283529160200191611c2f565b820191906000526020600020905b815481529060010190602001808311611c1257829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff166003811115611c6c57611c6c614529565b6003811115611c7d57611c7d614529565b8152602001600a8201548152602001600b82016040518060e00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152602001600582015481526020016006820154815250508152505090508060c001518160e001519250925050915091565b600b546001600160a01b0316331480611d23575060065461010090046001600160a01b031633145b80611d2d57503033145b611d495760405162461bcd60e51b8152600401610fc290614d60565b600160186000611d58866139e9565b6001600160a01b03168152602081019190915260400160002060010180549115156101000261ff001990921691909117905580611e66576000838152601a60209081526040808320546001600160a01b031683526018825290912083516005820181905591840151600682018190559091611dd39190614b80565b60038201558251611de590859061286e565b611dee84613e04565b611df7846139e9565b8351602085015160405163416288dd60e01b8152600481019290925260248201526001600160a01b03919091169063416288dd90604401600060405180830381600087803b158015611e4857600080fd5b505af1158015611e5c573d6000803e3d6000fd5b5050505050505050565b611aff83836000015161286e565b6000600a5460001415611e875750600090565b610bb6611e92610b9f565b600a5490613e6d565b6000611ea683613a04565b905080611ee35760405162461bcd60e51b815260206004820152600b60248201526a5a45524f5f53484152455360a81b6044820152606401610fc2565b611f186001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086613e82565b611f228282613f0c565b60408051848152602081018390526001600160a01b0384169133917fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d791015b60405180910390a3610f20565b611fb660405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b506040805161010081018252600c548152600d546020820152600e5491810191909152600f546060820152601054608082015260115460a082015260125460c082015260135460e082015290565b600b546001600160a01b031633148061202c575060065461010090046001600160a01b031633145b8061203657503033145b6120525760405162461bcd60e51b8152600401610fc290614d60565b60405163a9059cbb60e01b81526001600160a01b038381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044015b6020604051808303816000875af11580156120c2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aff9190614d15565b60065461010090046001600160a01b0316331480612183575060075460405163b700961360e01b81523360048201523060248201526000356001600160e01b03191660448201526001600160a01b039091169063b700961390606401602060405180830381865afa15801561215f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121839190614d15565b61218c57600080fd5b600780546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561223f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb69190614bd3565b600061226e83612ba0565b90506122a56001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333084613e82565b6122af8284613f0c565b60408051828152602081018590526001600160a01b0384169133917fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d79101611f61565b60018054610bc890614b98565b600061232c7f00000000000000000000000000000000000000000000000000000000000000006012614bec565b61233790600a614ce7565b610f209083614d8b565b6001600160a01b0316600090815260186020526040902060010154610100900460ff1690565b600b546001600160a01b031633148061238f575060065461010090046001600160a01b031633145b8061239957503033145b6123b55760405162461bcd60e51b8152600401610fc290614d60565b80602001516125655760008160c00151116124125760405162461bcd60e51b815260206004820181905260248201527f7072696e636970616c206d7573742062652067726561746572207468616e20306044820152606401610fc2565b6000816101000151116124675760405162461bcd60e51b815260206004820152601f60248201527f6475726174696f6e206d7573742062652067726561746572207468616e2030006044820152606401610fc2565b60008160800151116124bb5760405162461bcd60e51b815260206004820181905260248201527f6661636556616c7565206d7573742062652067726561746572207468616e20306044820152606401610fc2565b6009548160c0015110156125115760405162461bcd60e51b815260206004820152601d60248201527f4e6565647320746f20626520696e20646563696d616c20666f726d61740000006044820152606401610fc2565b60008160a00151116125655760405162461bcd60e51b815260206004820152601860248201527f6d7573742062652076616c696420696e737472756d656e7400000000000000006044820152606401610fc2565b33600090815260196020526040812080549161258083614daa565b90915550506101408101516001600160a01b031660009081526018602090815260409182902083518155818401516001820180549486015161ffff1990951691151561ff001916919091176101009415158502179055606084015160028201556080840151600382015560a0840151600482015560c0840151600582015560e08401516006820155918301516007830155610120830151805184939261262d9260088501929101906142ff565b506101408201516009820180546001600160a01b039092166001600160a01b0319831681178255610160850151926001600160a81b03191617600160a01b83600381111561267d5761267d614529565b0217905550610180820151600a8201556101a0909101518051600b830155602080820151600c840155604080830151600d8501556060830151600e8501556080830151600f85015560a080840151601086015560c09093015160119094019390935561014084015193909101516000908152601a9091522080546001600160a01b0319166001600160a01b03909216919091179055565b60065461010090046001600160a01b0316331461273057600080fd5b6001600160a01b03166000908152600860205260409020805460ff19166001179055565b61275c614250565b6000828152601a60209081526040808320546001600160a01b03168352601882529182902082516101c08101845281548152600182015460ff808216151594830194909452610100908190049093161515938101939093526002810154606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e08401526007810154918301919091526008810180546101208401919061191190614b98565b33600090815260036020526040812080548391908390612829908490614bec565b90915550506001600160a01b03831660008181526003602052604090819020805485019055513390600080516020614e6283398151915290610f149086815260200190565b6000612879836139e9565b6001600160a01b038116600090815260186020526040902060010154909150610100900460ff166128e35760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115108125b9cdd1c9d5b595b9d60621b6044820152606401610fc2565b60065460ff16156128fa576128f782611103565b91505b6040516370a0823160e01b81523060048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561295e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129829190614bd3565b8211156129d15760405162461bcd60e51b815260206004820152601760248201527f4e6f7420656e6f7567682062616c20696e207661756c740000000000000000006044820152606401610fc2565b81600a60008282546129e39190614b80565b90915550506001600160a01b03811660009081526018602052604081206002018054849290612a13908490614b80565b909155505060405163a9059cbb60e01b81526001600160a01b038281166004830152602482018490527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015612a87573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aab9190614d15565b612ae85760405162461bcd60e51b815260206004820152600e60248201526d11115413d4d25517d1905253115160921b6044820152606401610fc2565b6040518281526001600160a01b0382169033907f05fb08df9fd3a3099b9b7c09d3b801273152c1bae4b64e818fa08e212e882f849060200160405180910390a3505050565b600b546001600160a01b0316331480612b55575060065461010090046001600160a01b031633145b80612b5f57503033145b612b7b5760405162461bcd60e51b8152600401610fc290614d60565b6001600160a01b03166000908152601860205260409020600101805461ff0019169055565b6002546000908015610e9957610e94612bb7610b9f565b849083613ae8565b6000612bca84610f26565b9050336001600160a01b03831614612c3a576001600160a01b03821660009081526004602090815260408083203384529091529020546000198114612c3857612c138282614bec565b6001600160a01b03841660009081526004602090815260408083203384529091529020555b505b612c448482613f5e565b612c4e8282613da2565b60408051858152602081018390526001600160a01b03808516929086169133917ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db910160405180910390a4610eb26001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168486613fb3565b6000336001600160a01b03831614612d3d576001600160a01b03821660009081526004602090815260408083203384529091529020546000198114612d3b57612d168582614bec565b6001600160a01b03841660009081526004602090815260408083203384529091529020555b505b612d468461185b565b905080612d835760405162461bcd60e51b815260206004820152600b60248201526a5a45524f5f41535345545360a81b6044820152606401610fc2565b612d8d8185613f5e565b612d978285613da2565b60408051828152602081018690526001600160a01b03808516929086169133917ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db910160405180910390a4610eb26001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168483613fb3565b600b546001600160a01b0316331480612e3e575060065461010090046001600160a01b031633145b80612e4857503033145b612e645760405162461bcd60e51b8152600401610fc290614d60565b61133d8183613f0c565b6002546000908015610f4657610e9481612e86610b9f565b859190613ac9565b6000806000612eeb6040518061014001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b612ef485610c49565b6080860152606085018190526040850182905260208501929092529183529250612f445760405162461bcd60e51b81526020600482015260016024820152600360fc1b6044820152606401610fc2565b612f7b612f70826020015142612f5a9190614bec565b6009548451612f699082614b80565b9190614031565b6040830151906140ef565b60a08201526000858152601a60209081526040808320546001600160a01b03168352601890915290206002015460c0820152600b54604051634955b91f60e11b8152600481018790526001600160a01b03909116906392ab723e90602401602060405180830381865afa158015612ff6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061301a9190614bd3565b60e08201819052606082015161303091906140ef565b610100820181905261304a5760a0015192508291506130db565b61010081015160a082015161305e916140ef565b8160c0015110613074578060a001519350613093565b61010081015160c082015161308891613e6d565b600161012083015293505b8061012001516130d9576130d68160e001516130c18361010001518460a001516140ef90919063ffffffff16565b8360c001516130d09190614bec565b90613e6d565b92505b505b9193909250565b6001600160a01b038116600090815260036020526040812054610f2090610e75565b428410156131545760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610fc2565b60006001613160611782565b6001600160a01b038a811660008181526005602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938d166060840152608083018c905260a083019390935260c08083018b90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600084529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa15801561326c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116158015906132a25750876001600160a01b0316816001600160a01b0316145b6132df5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610fc2565b6001600160a01b0390811660009081526004602090815260408083208a8516808552908352928190208990555188815291928a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b600b546001600160a01b0316331480613370575060065461010090046001600160a01b031633145b8061337a57503033145b6133965760405162461bcd60e51b8152600401610fc290614d60565b6000818152601a60209081526040808320546001600160a01b031683526018909152902081158015906133d5575060098101546001600160a01b031615155b6134165760405162461bcd60e51b81526020600482015260126024820152711a5b9d985b1a59081a5b9cdd1c9d5b595b9d60721b6044820152606401610fc2565b6001810154610100900460ff16156134705760405162461bcd60e51b815260206004820152601e60248201527f63616e27742064656e7920617070726f76656420696e737472756d656e7400006044820152606401610fc2565b61133d82614104565b6001600160a01b038116600090815260036020526040812054610f209061185b565b600b546000908190819081906001600160a01b03163314806134cc575060065461010090046001600160a01b031633145b806134d657503033145b6134f25760405162461bcd60e51b8152600401610fc290614d60565b6000858152601a6020908152604080832054601c835292819020815180830183528154815260019091015460ff161515818401528151632938b58d60e21b815291516001600160a01b03909416939092849263a4e2d63492600480830193928290030181865afa15801561356a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061358e9190614d15565b6135c75760405162461bcd60e51b815260206004820152600a602482015269139bdd08131bd8dad95960b21b6044820152606401610fc2565b806020015180156135d85750805143115b6136145760405162461bcd60e51b815260206004820152600d60248201526c63616e2774207265736f6c766560981b6044820152606401610fc2565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561367b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369f9190614bd3565b90506000836001600160a01b0316631104aafd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156136e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137059190614bd3565b6001600160a01b038516600090815260186020908152604080832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e0830152600781015492820192909252600882018054949550929390926101208401916137ad90614b98565b80601f01602080910402602001604051908101604052809291908181526020018280546137d990614b98565b80156138265780601f106137fb57610100808354040283529160200191613826565b820191906000526020600020905b81548152906001019060200180831161380957829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff16600381111561386357613863614529565b600381111561387457613874614529565b8152600a8201546020808301919091526040805160e081018252600b8501548152600c85015481840152600d85015481830152600e8501546060820152600f8501546080820152601085015460a082015260119094015460c08501529182019290925260008d8152601b90925281205491925060ff9091169080808361393e5784608001518610925082613909576000613919565b8585608001516139199190614bec565b91508215613928576000613937565b60808501516139379087614bec565b9050613966565b8460c001518610925082613953576000613963565b858560c001516139639190614bec565b91505b6139708987613b55565b61397d8560a00151614104565b919d919c509a509098509650505050505050565b600b546001600160a01b03163314806139b9575060065461010090046001600160a01b031633145b806139c357503033145b6139df5760405162461bcd60e51b8152600401610fc290614d60565b61133d8183613da2565b6000908152601a60205260409020546001600160a01b031690565b6000610f2082612e6e565b600b546001600160a01b0316331480613a37575060065461010090046001600160a01b031633145b80613a4157503033145b613a5d5760405162461bcd60e51b8152600401610fc290614d60565b60065460ff1615613a7457613a7182611103565b91505b60405163a9059cbb60e01b81526001600160a01b038281166004830152602482018490527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016120a3565b828202811515841585830485141716613ae157600080fd5b0492915050565b828202811515841585830485141716613b0057600080fd5b6001826001830304018115150290509392505050565b6006546000906001600160a01b03848116610100909204161480610eb2575050506001600160a01b031660009081526008602052604090205460ff1690565b6001600160a01b038216600090815260186020526040902060010154610100900460ff16613bbc5760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115108125b9cdd1c9d5b595b9d60621b6044820152606401610fc2565b60065460ff1615613bd357613bd081611103565b90505b6001600160a01b03821660009081526018602052604081206002018054839290613bfe908490614bec565b9250508190555080600a6000828254613c179190614bec565b909155505060405163852a12e360e01b8152600481018290526001600160a01b0383169063852a12e3906024016020604051808303816000875af1158015613c63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c879190614d15565b613cc35760405162461bcd60e51b815260206004820152600d60248201526c14915111515357d19052531151609a1b6044820152606401610fc2565b6040518181526001600160a01b0383169033907fc8e1ada3e3428244364539f5fe21fa3bc368ed3634b0abc2355534eb12ca3524906020015b60405180910390a35050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051613d3a9190614dc5565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b6001600160a01b03821660009081526003602052604081208054839290613dca908490614bec565b90915550506002805482900390556040518181526000906001600160a01b03841690600080516020614e6283398151915290602001613cfc565b4260186000613e12846139e9565b6001600160a01b03166001600160a01b0316815260200190815260200160002060070154613e409190614b80565b60186000613e4d846139e9565b6001600160a01b031681526020810191909152604001600020600a015550565b6000610eb283670de0b6b3a764000084613ac9565b60006040516323b872dd60e01b81528460048201528360248201528260448201526020600060648360008a5af13d15601f3d1160016000511416171691505080613f055760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610fc2565b5050505050565b8060026000828254613f1e9190614b80565b90915550506001600160a01b038216600081815260036020908152604080832080548601905551848152600080516020614e628339815191529101613cfc565b613f6782611145565b61133d5760405162461bcd60e51b815260206004820152601c60248201527f4e6f7420656e6f756768206c6971756469747920696e207661756c74000000006044820152606401610fc2565b600060405163a9059cbb60e01b8152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061402b5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610fc2565b50505050565b60008380156140d15760018416801561404c57859250614050565b8392505b508260011c8460011c94505b84156140cb578560801c1561407057600080fd5b8586028181018181101561408357600080fd5b85900496505060018516156140c05785830283878204146140a95786156140a957600080fd5b818101818110156140b957600080fd5b8590049350505b8460011c945061405c565b506140e7565b8380156140e157600092506140e5565b8392505b505b509392505050565b6000610eb28383670de0b6b3a7640000613ac9565b6000818152601a60209081526040808320546001600160a01b031683526018909152902060048101546141795760405162461bcd60e51b815260206004820152601860248201527f696e737472756d656e7420646f65736e277420657869737400000000000000006044820152606401610fc2565b6000828152601a60209081526040808320546001600160a01b031683526018909152812081815560018101805461ffff19169055600281018290556003810182905560048101829055600581018290556006810182905560078101829055906141e56008830182614383565b506009810180546001600160a81b03191690556000600a8201819055600b8201819055600c8201819055600d8201819055600e8201819055600f820181905560108201819055601190910181905591825250601a6020526040902080546001600160a01b0319169055565b604080516101c08101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201526101408101829052906101608201908152602001600081526020016142fa6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b82805461430b90614b98565b90600052602060002090601f01602090048101928261432d5760008555614373565b82601f1061434657805160ff1916838001178555614373565b82800160010185558215614373579182015b82811115614373578251825591602001919060010190614358565b5061437f9291506143b9565b5090565b50805461438f90614b98565b6000825580601f1061439f575050565b601f0160209004906000526020600020908101906117e291905b5b8082111561437f57600081556001016143ba565b6000815180845260005b818110156143f4576020818501810151868301820152016143d8565b81811115614406576000602083870101525b50601f01601f19169290920160200192915050565b602081526000610eb260208301846143ce565b60006020828403121561444057600080fd5b5035919050565b6001600160a01b03811681146117e257600080fd5b803561446781614447565b919050565b6000806040838503121561447f57600080fd5b823561448a81614447565b946020939093013593505050565b6000602082840312156144aa57600080fd5b8135610eb281614447565b600080604083850312156144c857600080fd5b50508035926020909101359150565b80151581146117e257600080fd5b8035614467816144d7565b6000806040838503121561450357600080fd5b823561450e81614447565b9150602083013561451e816144d7565b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b6004811061455d57634e487b7160e01b600052602160045260246000fd5b9052565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c08301525050565b8e81528d151560208201528c151560408201528b60608201528a60808201528960a08201528860c08201528760e08201528661010082015261028061012082015260006145f66102808301886143ce565b6001600160a01b038716610140840152905061461661016083018661453f565b8361018083015261462b6101a0830184614561565b9f9e505050505050505050505050505050565b60008060006060848603121561465357600080fd5b833561465e81614447565b9250602084013561466e81614447565b929592945050506040919091013590565b60208152815160208201526000602083015161469f604084018215159052565b50604083015180151560608401525060608301516080830152608083015160a083015260a083015160c083015260c083015160e083015260e0830151610100818185015280850151915050610120818185015280850151915050610140610280818501526147116102a08501836143ce565b9085015190915061016061472f858201836001600160a01b03169052565b85015190506101806147438582018361453f565b8501516101a08581019190915285015190506140e76101c0850182614561565b634e487b7160e01b600052604160045260246000fd5b6040516101c0810167ffffffffffffffff8111828210171561479d5761479d614763565b60405290565b600080600083850360808112156147b957600080fd5b843593506040601f19820112156147cf57600080fd5b506040516040810181811067ffffffffffffffff821117156147f3576147f3614763565b60409081526020868101358352908601359082015291506060840135614818816144d7565b809150509250925092565b6000806040838503121561483657600080fd5b82359150602083013561451e81614447565b600082601f83011261485957600080fd5b813567ffffffffffffffff8082111561487457614874614763565b604051601f8301601f19908116603f0116810190828211818310171561489c5761489c614763565b816040528381528660208588010111156148b557600080fd5b836020870160208301376000602085830101528094505050505092915050565b80356004811061446757600080fd5b600060e082840312156148f657600080fd5b60405160e0810181811067ffffffffffffffff8211171561491957614919614763565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c08201525092915050565b60006020828403121561497a57600080fd5b813567ffffffffffffffff8082111561499257600080fd5b9083019061028082860312156149a757600080fd5b6149af614779565b823581526149bf602084016144e5565b60208201526149d0604084016144e5565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013583811115614a2757600080fd5b614a3388828701614848565b8284015250506101409150614a4982840161445c565b828201526101609150614a5d8284016148d5565b82820152610180915081830135828201526101a09150614a7f868385016148e4565b91810191909152949350505050565b600080600060608486031215614aa357600080fd5b833592506020840135614ab581614447565b9150604084013561481881614447565b600080600080600080600060e0888a031215614ae057600080fd5b8735614aeb81614447565b96506020880135614afb81614447565b95506040880135945060608801359350608088013560ff81168114614b1f57600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215614b4f57600080fd5b8235614b5a81614447565b9150602083013561451e81614447565b634e487b7160e01b600052601160045260246000fd5b60008219821115614b9357614b93614b6a565b500190565b600181811c90821680614bac57607f821691505b60208210811415614bcd57634e487b7160e01b600052602260045260246000fd5b50919050565b600060208284031215614be557600080fd5b5051919050565b600082821015614bfe57614bfe614b6a565b500390565b600181815b80851115614c3e578160001904821115614c2457614c24614b6a565b80851615614c3157918102915b93841c9390800290614c08565b509250929050565b600082614c5557506001610f20565b81614c6257506000610f20565b8160018114614c785760028114614c8257614c9e565b6001915050610f20565b60ff841115614c9357614c93614b6a565b50506001821b610f20565b5060208310610133831016604e8410600b8410161715614cc1575081810a610f20565b614ccb8383614c03565b8060001904821115614cdf57614cdf614b6a565b029392505050565b6000610eb28383614c46565b600082614d1057634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215614d2757600080fd5b8151610eb2816144d7565b600080600060608486031215614d4757600080fd5b8351925060208401519150604084015190509250925092565b60208082526011908201527034b9903737ba1031b7b73a3937b63632b960791b604082015260600190565b6000816000190483118215151615614da557614da5614b6a565b500290565b6000600019821415614dbe57614dbe614b6a565b5060010190565b600080835481600182811c915080831680614de157607f831692505b6020808410821415614e0157634e487b7160e01b86526022600452602486fd5b818015614e155760018114614e2657614e53565b60ff19861689528489019650614e53565b60008a81526020902060005b86811015614e4b5781548b820152908501908301614e32565b505084890196505b50949897505050505050505056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa26469706673582212200ee0846f4685a973cd65fc45f61290180b29cc1dfc3fb7e00685e0d2498000af64736f6c634300080c0033a264697066735822122002688620e74023ac2e11f2786398c6b32fb9e42f42a2f02d0d6d7d659b63fe0764736f6c634300080c0033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620000465760003560e01c8063264a6208146200004b578063652b9b411462000068578063da33133314620000a8575b600080fd5b6200005560025481565b6040519081526020015b60405180910390f35b62000097620000793660046200030a565b6001600160a01b031660009081526001602052604090205460ff1690565b60405190151581526020016200005f565b620000bf620000b93660046200032f565b620000df565b604080516001600160a01b0390931683526020830191909152016200005f565b60035460009081906001600160a01b03163314806200010857506000546001600160a01b031633145b806200011357503330145b620001595760405162461bcd60e51b815260206004820152601160248201527034b9903737ba1031b7b73a3937b63632b960791b60448201526064015b60405180910390fd5b662386f26fc1000083604001511015620001a85760405162461bcd60e51b815260206004820152600f60248201526e105b1c1a18481d1bdbc81cdb585b1b608a1b604482015260640162000150565b6000898960008054906101000a90046001600160a01b03168a8a8a8a8a604051620001d390620002df565b6001600160a01b0398891681529688166020808901919091529590971660408088019190915293151560608088019190915260808088019490945260a08088019390935260c080880192909252875160e0808901919091529588015161010088015284880151610120880152870151610140870152918601516101608601528501516101808501528401516101a08401529201516101c08201529051908190036101e001906000f0801580156200028e573d6000803e3d6000fd5b506001600160a01b03811660009081526001602081905260408220805460ff191690911790556002805492935090620002c78362000444565b9091555050600254909a909950975050505050505050565b61587f806200046f83390190565b80356001600160a01b03811681146200030557600080fd5b919050565b6000602082840312156200031d57600080fd5b6200032882620002ed565b9392505050565b60008060008060008060008789036101c08112156200034d57600080fd5b6200035889620002ed565b97506200036860208a01620002ed565b9650604089013580151581146200037e57600080fd5b9550606089013594506080890135935060a0890135925061010060bf198201811315620003aa57600080fd5b604051915080820182811067ffffffffffffffff82111715620003dd57634e487b7160e01b600052604160045260246000fd5b806040525060c08a0135825260e08a01356020830152808a01356040830152506101208901356060820152610140890135608082015261016089013560a082015261018089013560c08201526101a089013560e08201528091505092959891949750929550565b60006000198214156200046757634e487b7160e01b600052601160045260246000fd5b506001019056fe6101406040523480156200001257600080fd5b506040516200587f3803806200587f8339810160408190526200003591620005ab565b8588896001600160a01b03166306fdde036040518163ffffffff1660e01b8152600401600060405180830381865afa15801562000076573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052620000a09190810190620006dc565b604051602001620000b2919062000794565b6040516020818303038152906040528a6001600160a01b03166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa15801562000100573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526200012a9190810190620006dc565b6040516020016200013c9190620007d5565b60405160208183030381529060405281816012826000908051906020019062000167929190620004a6565b5081516200017d906001906020850190620004a6565b5060ff81166080524660a052620001936200040a565b60c0525050506001600160a01b03831660e08190526040805163313ce56760e01b8152905163313ce567916004808201926020929091908290030181865afa158015620001e4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020a919062000801565b60ff166101008181525050601260ff16836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000259573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200027f919062000801565b6006805460ff191660ff9283169390931415928317905516156200031a57601260ff16836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015620002e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000307919062000801565b60ff16106200031a576200031a6200082d565b505060068054610100600160a81b0319166101006001600160a01b0385169081029190911790915560405190915033907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7690600090a3506001600160a01b0388811661012052670de0b6b3a7640000600955600b80546001600160a01b0319169189169190911790556014805460ff19168615151790556015849055601683905560178290558051600c556020810151600d556040810151600e556060810151600f55608081015160105560a081015160115560c081015160125560e00151601355506200092495505050505050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60006040516200043e919062000880565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b828054620004b49062000843565b90600052602060002090601f016020900481019282620004d8576000855562000523565b82601f10620004f357805160ff191683800117855562000523565b8280016001018555821562000523579182015b828111156200052357825182559160200191906001019062000506565b506200053192915062000535565b5090565b5b8082111562000531576000815560010162000536565b80516001600160a01b03811681146200056457600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b0381118282101715620005a557620005a562000569565b60405290565b600080600080600080600080888a036101e0811215620005ca57600080fd5b620005d58a6200054c565b9850620005e560208b016200054c565b9750620005f560408b016200054c565b965060608a015180151581146200060b57600080fd5b8096505060808a0151945060a08a0151935060c08a015192506101008060df19830112156200063957600080fd5b620006436200057f565b915060e08b01518252808b01516020830152506101208a015160408201526101408a015160608201526101608a015160808201526101808a015160a08201526101a08a015160c08201526101c08a015160e0820152809150509295985092959890939650565b60005b83811015620006c6578181015183820152602001620006ac565b83811115620006d6576000848401525b50505050565b600060208284031215620006ef57600080fd5b81516001600160401b03808211156200070757600080fd5b818401915084601f8301126200071c57600080fd5b81518181111562000731576200073162000569565b604051601f8201601f19908116603f011681019083821181831017156200075c576200075c62000569565b816040528281528760208487010111156200077657600080fd5b62000789836020830160208801620006a9565b979650505050505050565b6603232b134ba30960cd1b815260008251620007b8816007850160208701620006a9565b650815985d5b1d60d21b6007939091019283015250600d01919050565b61323160f11b815260008251620007f4816002850160208701620006a9565b9190910160020192915050565b6000602082840312156200081457600080fd5b815160ff811681146200082657600080fd5b9392505050565b634e487b7160e01b600052600160045260246000fd5b600181811c908216806200085857607f821691505b602082108114156200087a57634e487b7160e01b600052602260045260246000fd5b50919050565b600080835481600182811c9150808316806200089d57607f831692505b6020808410821415620008be57634e487b7160e01b86526022600452602486fd5b818015620008d55760018114620008e75762000916565b60ff1986168952848901965062000916565b60008a81526020902060005b868110156200090e5781548b820152908501908301620008f3565b505084890196505b509498975050505050505050565b60805160a05160c05160e0516101005161012051614eb7620009c8600039600081816109e20152818161116701528181612078015281816121f00152818161290f01528181612a3e0152818161362c0152613a9a01526000818161110a015261230601526000818161063701528181611ef00152818161227d01528181612ca60152612def015260006117b601526000611786015260006105f60152614eb76000f3fe608060405234801561001057600080fd5b50600436106104545760003560e01c80637ecebe0011610241578063c5d664c61161013b578063dc361a13116100c3578063edb53d3e11610087578063edb53d3e14610b4c578063ef8b30f714610b5f578063f05bcfb414610b72578063f7d070de14610b85578063fc173fc614610b9257600080fd5b8063dc361a1314610ab0578063dd62ed3e14610ac3578063e134cc8214610aee578063e3fac5bf14610b25578063e9a23d3a14610b3857600080fd5b8063ca13e4501161010a578063ca13e45014610a20578063ce96cb7714610a4e578063d505accf14610a61578063d746d3ef14610a74578063d905777e14610a8757600080fd5b8063c5d664c6146109dd578063c63d75b614610671578063c6e6f59214610a04578063c83baf4e14610a1757600080fd5b80639ec4d40e116101c9578063b3d7f6b91161018d578063b3d7f6b91461097e578063b460af9414610991578063ba087652146109a4578063bebf7a04146109b7578063bf7e214f146109ca57600080fd5b80639ec4d40e146108f9578063a9059cbb1461090c578063ab0c79d01461091f578063ab0fd37e14610932578063b19b1f911461096b57600080fd5b806395d89b411161021057806395d89b41146108a557806396ce9d5a146108ad57806396d64879146108c057806398d796e7146108d35780639d0eba61146108e657600080fd5b80637ecebe0014610852578063841219e5146108725780638da5cb5b1461087a57806394bf804d1461089257600080fd5b806338d52e0f1161035257806360d4efa4116102da5780636e553f651161029e5780636e553f651461079057806370a08231146107a35780637572cb1f146107c357806379e20bdc1461082c5780637a9e5e4b1461083f57600080fd5b806360d4efa414610724578063692eba091461074c5780636a9f1bdb1461076c5780636c321c8a1461077f5780636c8ae38c1461078757600080fd5b80634cdad506116103215780634cdad506146106ac5780634dc54a38146106bf57806350c6e6cf146106df57806359dc5c6f146107085780635f260bb81461071b57600080fd5b806338d52e0f14610632578063402d267d1461067157806342966c6814610686578063471e1cea1461069957600080fd5b8063139f4b6f116103e057806322f0e069116103a457806322f0e0691461059e57806323b872dd146105cb5780632b858734146105de578063313ce567146105f15780633644e5151461062a57600080fd5b8063139f4b6f1461054957806313af40351461055c57806316f6cb071461056f57806318160ddd14610582578063213a7d521461058b57600080fd5b8063095ea7b311610427578063095ea7b3146104d75780630a28a477146104fa5780630e5c011e1461050d5780630f65cbc4146105225780631316dbde1461053657600080fd5b806301e1d1141461045957806306fdde0314610474578063076125a91461048957806307a2d13a146104c4575b600080fd5b610461610b9f565b6040519081526020015b60405180910390f35b61047c610bbb565b60405161046b919061441b565b61049c61049736600461442e565b610c49565b604080519586526020860194909452928401919091526060830152608082015260a00161046b565b6104616104d236600461442e565b610e75565b6104ea6104e536600461446c565b610eb9565b604051901515815260200161046b565b61046161050836600461442e565b610f26565b61052061051b366004614498565b610f5f565b005b61046161053036600461442e565b50600090565b61046161054436600461442e565b611103565b6104ea61055736600461442e565b611145565b61052061056a366004614498565b6111da565b61052061057d3660046144b5565b61127f565b61046160025481565b6105206105993660046144f0565b611341565b6105b16105ac366004614498565b6113aa565b60405161046b9e9d9c9b9a999897969594939291906145a5565b6104ea6105d936600461463e565b6114f3565b6105206105ec36600461442e565b6115d3565b6106187f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff909116815260200161046b565b610461611782565b6106597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161046b565b61046161067f366004614498565b5060001990565b61052061069436600461442e565b6117d8565b6104ea6106a736600461442e565b6117e5565b6104616106ba36600461442e565b61185b565b6106d26106cd366004614498565b611866565b60405161046b919061467f565b6106596106ed36600461442e565b601a602052600090815260409020546001600160a01b031681565b61052061071636600461442e565b611a40565b61046160165481565b61073761073236600461442e565b611b04565b6040805192835260208301919091520161046b565b61046161075a366004614498565b60196020526000908152604090205481565b61052061077a3660046147a3565b611cfb565b610461611e74565b61046160155481565b61046161079e366004614823565b611e9b565b6104616107b1366004614498565b60036020526000908152604090205481565b6107cb611f6e565b60405161046b9190600061010082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b61052061083a36600461446c565b612004565b61052061084d366004614498565b6120e6565b610461610860366004614498565b60056020526000908152604090205481565b6104616121d8565b6006546106599061010090046001600160a01b031681565b6104616108a0366004614823565b612263565b61047c6122f2565b6104616108bb36600461442e565b6122ff565b6104ea6108ce366004614498565b612341565b6105206108e1366004614968565b612367565b6105206108f4366004614498565b612714565b6106d261090736600461442e565b612754565b6104ea61091a36600461446c565b612808565b61052061092d3660046144b5565b61286e565b61046161094036600461442e565b6000908152601a60209081526040808320546001600160a01b03168352601890915290206002015490565b610520610979366004614498565b612b2d565b61046161098c36600461442e565b612ba0565b61046161099f366004614a8e565b612bbf565b6104616109b2366004614a8e565b612ccd565b6105206109c5366004614823565b612e16565b600754610659906001600160a01b031681565b6106597f000000000000000000000000000000000000000000000000000000000000000081565b610461610a1236600461442e565b612e6e565b61046160175481565b610a33610a2e36600461442e565b612e8e565b6040805193845260208401929092529082015260600161046b565b610461610a5c366004614498565b6130e2565b610520610a6f366004614ac5565b613104565b610520610a8236600461442e565b613348565b610461610a95366004614498565b6001600160a01b031660009081526003602052604090205490565b610461610abe366004614498565b613479565b610461610ad1366004614b3c565b600460209081526000928352604080842090915290825290205481565b610b01610afc36600461442e565b61349b565b6040805194151585526020850193909352918301521515606082015260800161046b565b610520610b33366004614823565b613991565b6104ea610b46366004614498565b50600190565b610659610b5a36600461442e565b6139e9565b610461610b6d36600461442e565b613a04565b610520610b80366004614823565b613a0f565b6014546104ea9060ff1681565b6006546104ea9060ff1681565b6000610ba96121d8565b600a54610bb69190614b80565b905090565b60008054610bc890614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054610bf490614b98565b8015610c415780601f10610c1657610100808354040283529160200191610c41565b820191906000526020600020905b815481529060010190602001808311610c2457829003601f168201915b505050505081565b6000818152601a60209081526040808320546001600160a01b031683526018825280832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e08301526007810154928201929092526008820180548493849384938493849391610120840191610cfe90614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054610d2a90614b98565b8015610d775780601f10610d4c57610100808354040283529160200191610d77565b820191906000526020600020905b815481529060010190602001808311610d5a57829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff166003811115610db457610db4614529565b6003811115610dc557610dc5614529565b8152602001600a8201548152602001600b82016040518060e0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815260200160058201548152602001600682015481525050815250509050806101a0015160400151816101a0015160600151826101a0015160800151836101a0015160a00151846101a0015160c00151955095509550955095505091939590929450565b6002546000908015610e9957610e94610e8c610b9f565b849083613ac9565b610eb2565b60065460ff16610ea95782610eb2565b610eb283611103565b9392505050565b3360008181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590610f149086815260200190565b60405180910390a35060015b92915050565b6002546000908015610f4657610e9481610f3e610b9f565b859190613ae8565b60065460ff16610f565782610eb2565b610eb2836122ff565b6001600160a01b038116600090815260186020526040902060010154610100900460ff16610fcb5760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115117d25b9cdd1c9d5b595b9d60621b60448201526064015b60405180910390fd5b6001600160a01b038116600081815260186020526040808220600a5460028201549251633af9e66960e01b8152600481018690529194909391633af9e66990602401602060405180830381865afa15801561102a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104e9190614bd3565b90508082141561105f575050505050565b60028401819055600082821015806110805761107b8385614bec565b61108a565b61108a8484614bec565b9150806110a05761109b8286614bec565b6110aa565b6110aa8286614b80565b600a5560408051848152602081018490528215158183015290516001600160a01b038916917f633a7d7c82bd537c647d654b96128a9b02a675bd73abe910b82f875ce4776391919081900360600190a250505050505050565b60006111307f00000000000000000000000000000000000000000000000000000000000000006012614bec565b61113b90600a614ce7565b610f209083614cf3565b6040516370a0823160e01b815230600482015260009082906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa1580156111ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d29190614bd3565b101592915050565b6111f0336000356001600160e01b031916613b16565b61122b5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610fc2565b60068054610100600160a81b0319166101006001600160a01b0384169081029190911790915560405133907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7690600090a350565b611288826139e9565b6001600160a01b031663537d9409826040518263ffffffff1660e01b81526004016112b591815260200190565b602060405180830381865afa1580156112d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112f69190614d15565b61132b5760405162461bcd60e51b8152600401610fc290602080825260049082015263216c697160e01b604082015260600190565b61133d611337836139e9565b82613b55565b5050565b336001600160a01b038316148061135c575061135c82612341565b61136557600080fd5b6001600160a01b03821660009081526018602052604090206004015461138a816115d3565b6000908152601b60205260409020805460ff191691151591909117905550565b601860205260009081526040902080546001820154600283015460038401546004850154600586015460068701546007880154600889018054989960ff808a169a610100909a0416989091906113ff90614b98565b80601f016020809104026020016040519081016040528092919081815260200182805461142b90614b98565b80156114785780601f1061144d57610100808354040283529160200191611478565b820191906000526020600020905b81548152906001019060200180831161145b57829003601f168201915b505050506009830154600a8401546040805160e081018252600b8701548152600c8701546020820152600d87015491810191909152600e8601546060820152600f8601546080820152601086015460a082015260119095015460c086015292936001600160a01b03821693600160a01b90920460ff1692508e565b6001600160a01b0383166000908152600460209081526040808320338452909152812054600019811461154f5761152a8382614bec565b6001600160a01b03861660009081526004602090815260408083203384529091529020555b6001600160a01b03851660009081526003602052604081208054859290611577908490614bec565b90915550506001600160a01b0380851660008181526003602052604090819020805487019055519091871690600080516020614e62833981519152906115c09087815260200190565b60405180910390a3506001949350505050565b6000818152601a60205260409020546001600160a01b0316338114806116035750600b546001600160a01b031633145b61163d5760405162461bcd60e51b815260206004820152600b60248201526a139bdd08185b1b1bddd95960aa1b6044820152606401610fc2565b61164681612341565b6116805760405162461bcd60e51b815260206004820152600b60248201526a139bdd081d1c9d5cdd195960aa1b6044820152606401610fc2565b806001600160a01b03166349dcf4ed6040518163ffffffff1660e01b81526004016060604051808303816000875af11580156116c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116e49190614d32565b5050506116f081610f5f565b806001600160a01b031663f3aa68d36040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561172b57600080fd5b505af115801561173f573d6000803e3d6000fd5b5050604080518082018252438152600160208083018281526000988952601c909152929096209051815590519401805460ff191694151594909417909355505050565b60007f000000000000000000000000000000000000000000000000000000000000000046146117b357610bb6613d08565b507f000000000000000000000000000000000000000000000000000000000000000090565b6117e23382613da2565b50565b6000818152601a6020908152604080832054815163041f3aa560e51b815291516001600160a01b03909116926383e754a092600480820193918290030181865afa158015611837573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f209190614d15565b6000610f2082610e75565b61186e614250565b6001600160a01b03821660009081526018602090815260409182902082516101c08101845281548152600182015460ff808216151594830194909452610100908190049093161515938101939093526002810154606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e08401526007810154918301919091526008810180546101208401919061191190614b98565b80601f016020809104026020016040519081016040528092919081815260200182805461193d90614b98565b801561198a5780601f1061195f5761010080835404028352916020019161198a565b820191906000526020600020905b81548152906001019060200180831161196d57829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff1660038111156119c7576119c7614529565b60038111156119d8576119d8614529565b8152600a8201546020808301919091526040805160e081018252600b8501548152600c85015492810192909252600d84015482820152600e8401546060830152600f8401546080830152601084015460a083015260119093015460c082015291015292915050565b600b546001600160a01b0316331480611a68575060065461010090046001600160a01b031633145b80611a7257503033145b611a8e5760405162461bcd60e51b8152600401610fc290614d60565b6000611a99826139e9565b9050806001600160a01b03166350bb4beb6040518163ffffffff1660e01b81526004016020604051808303816000875af1158015611adb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aff9190614bd3565b505050565b6000818152601a60209081526040808320546001600160a01b031683526018825280832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e08301526007810154928201929092526008820180548493849392909161012084019190611bb690614b98565b80601f0160208091040260200160405190810160405280929190818152602001828054611be290614b98565b8015611c2f5780601f10611c0457610100808354040283529160200191611c2f565b820191906000526020600020905b815481529060010190602001808311611c1257829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff166003811115611c6c57611c6c614529565b6003811115611c7d57611c7d614529565b8152602001600a8201548152602001600b82016040518060e00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152602001600582015481526020016006820154815250508152505090508060c001518160e001519250925050915091565b600b546001600160a01b0316331480611d23575060065461010090046001600160a01b031633145b80611d2d57503033145b611d495760405162461bcd60e51b8152600401610fc290614d60565b600160186000611d58866139e9565b6001600160a01b03168152602081019190915260400160002060010180549115156101000261ff001990921691909117905580611e66576000838152601a60209081526040808320546001600160a01b031683526018825290912083516005820181905591840151600682018190559091611dd39190614b80565b60038201558251611de590859061286e565b611dee84613e04565b611df7846139e9565b8351602085015160405163416288dd60e01b8152600481019290925260248201526001600160a01b03919091169063416288dd90604401600060405180830381600087803b158015611e4857600080fd5b505af1158015611e5c573d6000803e3d6000fd5b5050505050505050565b611aff83836000015161286e565b6000600a5460001415611e875750600090565b610bb6611e92610b9f565b600a5490613e6d565b6000611ea683613a04565b905080611ee35760405162461bcd60e51b815260206004820152600b60248201526a5a45524f5f53484152455360a81b6044820152606401610fc2565b611f186001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086613e82565b611f228282613f0c565b60408051848152602081018390526001600160a01b0384169133917fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d791015b60405180910390a3610f20565b611fb660405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b506040805161010081018252600c548152600d546020820152600e5491810191909152600f546060820152601054608082015260115460a082015260125460c082015260135460e082015290565b600b546001600160a01b031633148061202c575060065461010090046001600160a01b031633145b8061203657503033145b6120525760405162461bcd60e51b8152600401610fc290614d60565b60405163a9059cbb60e01b81526001600160a01b038381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044015b6020604051808303816000875af11580156120c2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aff9190614d15565b60065461010090046001600160a01b0316331480612183575060075460405163b700961360e01b81523360048201523060248201526000356001600160e01b03191660448201526001600160a01b039091169063b700961390606401602060405180830381865afa15801561215f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121839190614d15565b61218c57600080fd5b600780546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561223f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb69190614bd3565b600061226e83612ba0565b90506122a56001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333084613e82565b6122af8284613f0c565b60408051828152602081018590526001600160a01b0384169133917fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d79101611f61565b60018054610bc890614b98565b600061232c7f00000000000000000000000000000000000000000000000000000000000000006012614bec565b61233790600a614ce7565b610f209083614d8b565b6001600160a01b0316600090815260186020526040902060010154610100900460ff1690565b600b546001600160a01b031633148061238f575060065461010090046001600160a01b031633145b8061239957503033145b6123b55760405162461bcd60e51b8152600401610fc290614d60565b80602001516125655760008160c00151116124125760405162461bcd60e51b815260206004820181905260248201527f7072696e636970616c206d7573742062652067726561746572207468616e20306044820152606401610fc2565b6000816101000151116124675760405162461bcd60e51b815260206004820152601f60248201527f6475726174696f6e206d7573742062652067726561746572207468616e2030006044820152606401610fc2565b60008160800151116124bb5760405162461bcd60e51b815260206004820181905260248201527f6661636556616c7565206d7573742062652067726561746572207468616e20306044820152606401610fc2565b6009548160c0015110156125115760405162461bcd60e51b815260206004820152601d60248201527f4e6565647320746f20626520696e20646563696d616c20666f726d61740000006044820152606401610fc2565b60008160a00151116125655760405162461bcd60e51b815260206004820152601860248201527f6d7573742062652076616c696420696e737472756d656e7400000000000000006044820152606401610fc2565b33600090815260196020526040812080549161258083614daa565b90915550506101408101516001600160a01b031660009081526018602090815260409182902083518155818401516001820180549486015161ffff1990951691151561ff001916919091176101009415158502179055606084015160028201556080840151600382015560a0840151600482015560c0840151600582015560e08401516006820155918301516007830155610120830151805184939261262d9260088501929101906142ff565b506101408201516009820180546001600160a01b039092166001600160a01b0319831681178255610160850151926001600160a81b03191617600160a01b83600381111561267d5761267d614529565b0217905550610180820151600a8201556101a0909101518051600b830155602080820151600c840155604080830151600d8501556060830151600e8501556080830151600f85015560a080840151601086015560c09093015160119094019390935561014084015193909101516000908152601a9091522080546001600160a01b0319166001600160a01b03909216919091179055565b60065461010090046001600160a01b0316331461273057600080fd5b6001600160a01b03166000908152600860205260409020805460ff19166001179055565b61275c614250565b6000828152601a60209081526040808320546001600160a01b03168352601882529182902082516101c08101845281548152600182015460ff808216151594830194909452610100908190049093161515938101939093526002810154606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e08401526007810154918301919091526008810180546101208401919061191190614b98565b33600090815260036020526040812080548391908390612829908490614bec565b90915550506001600160a01b03831660008181526003602052604090819020805485019055513390600080516020614e6283398151915290610f149086815260200190565b6000612879836139e9565b6001600160a01b038116600090815260186020526040902060010154909150610100900460ff166128e35760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115108125b9cdd1c9d5b595b9d60621b6044820152606401610fc2565b60065460ff16156128fa576128f782611103565b91505b6040516370a0823160e01b81523060048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561295e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129829190614bd3565b8211156129d15760405162461bcd60e51b815260206004820152601760248201527f4e6f7420656e6f7567682062616c20696e207661756c740000000000000000006044820152606401610fc2565b81600a60008282546129e39190614b80565b90915550506001600160a01b03811660009081526018602052604081206002018054849290612a13908490614b80565b909155505060405163a9059cbb60e01b81526001600160a01b038281166004830152602482018490527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015612a87573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aab9190614d15565b612ae85760405162461bcd60e51b815260206004820152600e60248201526d11115413d4d25517d1905253115160921b6044820152606401610fc2565b6040518281526001600160a01b0382169033907f05fb08df9fd3a3099b9b7c09d3b801273152c1bae4b64e818fa08e212e882f849060200160405180910390a3505050565b600b546001600160a01b0316331480612b55575060065461010090046001600160a01b031633145b80612b5f57503033145b612b7b5760405162461bcd60e51b8152600401610fc290614d60565b6001600160a01b03166000908152601860205260409020600101805461ff0019169055565b6002546000908015610e9957610e94612bb7610b9f565b849083613ae8565b6000612bca84610f26565b9050336001600160a01b03831614612c3a576001600160a01b03821660009081526004602090815260408083203384529091529020546000198114612c3857612c138282614bec565b6001600160a01b03841660009081526004602090815260408083203384529091529020555b505b612c448482613f5e565b612c4e8282613da2565b60408051858152602081018390526001600160a01b03808516929086169133917ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db910160405180910390a4610eb26001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168486613fb3565b6000336001600160a01b03831614612d3d576001600160a01b03821660009081526004602090815260408083203384529091529020546000198114612d3b57612d168582614bec565b6001600160a01b03841660009081526004602090815260408083203384529091529020555b505b612d468461185b565b905080612d835760405162461bcd60e51b815260206004820152600b60248201526a5a45524f5f41535345545360a81b6044820152606401610fc2565b612d8d8185613f5e565b612d978285613da2565b60408051828152602081018690526001600160a01b03808516929086169133917ffbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db910160405180910390a4610eb26001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168483613fb3565b600b546001600160a01b0316331480612e3e575060065461010090046001600160a01b031633145b80612e4857503033145b612e645760405162461bcd60e51b8152600401610fc290614d60565b61133d8183613f0c565b6002546000908015610f4657610e9481612e86610b9f565b859190613ac9565b6000806000612eeb6040518061014001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b612ef485610c49565b6080860152606085018190526040850182905260208501929092529183529250612f445760405162461bcd60e51b81526020600482015260016024820152600360fc1b6044820152606401610fc2565b612f7b612f70826020015142612f5a9190614bec565b6009548451612f699082614b80565b9190614031565b6040830151906140ef565b60a08201526000858152601a60209081526040808320546001600160a01b03168352601890915290206002015460c0820152600b54604051634955b91f60e11b8152600481018790526001600160a01b03909116906392ab723e90602401602060405180830381865afa158015612ff6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061301a9190614bd3565b60e08201819052606082015161303091906140ef565b610100820181905261304a5760a0015192508291506130db565b61010081015160a082015161305e916140ef565b8160c0015110613074578060a001519350613093565b61010081015160c082015161308891613e6d565b600161012083015293505b8061012001516130d9576130d68160e001516130c18361010001518460a001516140ef90919063ffffffff16565b8360c001516130d09190614bec565b90613e6d565b92505b505b9193909250565b6001600160a01b038116600090815260036020526040812054610f2090610e75565b428410156131545760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610fc2565b60006001613160611782565b6001600160a01b038a811660008181526005602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938d166060840152608083018c905260a083019390935260c08083018b90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600084529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa15801561326c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116158015906132a25750876001600160a01b0316816001600160a01b0316145b6132df5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610fc2565b6001600160a01b0390811660009081526004602090815260408083208a8516808552908352928190208990555188815291928a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b600b546001600160a01b0316331480613370575060065461010090046001600160a01b031633145b8061337a57503033145b6133965760405162461bcd60e51b8152600401610fc290614d60565b6000818152601a60209081526040808320546001600160a01b031683526018909152902081158015906133d5575060098101546001600160a01b031615155b6134165760405162461bcd60e51b81526020600482015260126024820152711a5b9d985b1a59081a5b9cdd1c9d5b595b9d60721b6044820152606401610fc2565b6001810154610100900460ff16156134705760405162461bcd60e51b815260206004820152601e60248201527f63616e27742064656e7920617070726f76656420696e737472756d656e7400006044820152606401610fc2565b61133d82614104565b6001600160a01b038116600090815260036020526040812054610f209061185b565b600b546000908190819081906001600160a01b03163314806134cc575060065461010090046001600160a01b031633145b806134d657503033145b6134f25760405162461bcd60e51b8152600401610fc290614d60565b6000858152601a6020908152604080832054601c835292819020815180830183528154815260019091015460ff161515818401528151632938b58d60e21b815291516001600160a01b03909416939092849263a4e2d63492600480830193928290030181865afa15801561356a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061358e9190614d15565b6135c75760405162461bcd60e51b815260206004820152600a602482015269139bdd08131bd8dad95960b21b6044820152606401610fc2565b806020015180156135d85750805143115b6136145760405162461bcd60e51b815260206004820152600d60248201526c63616e2774207265736f6c766560981b6044820152606401610fc2565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561367b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369f9190614bd3565b90506000836001600160a01b0316631104aafd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156136e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137059190614bd3565b6001600160a01b038516600090815260186020908152604080832081516101c08101835281548152600182015460ff808216151595830195909552610100908190049094161515928101929092526002810154606083015260038101546080830152600481015460a0830152600581015460c0830152600681015460e0830152600781015492820192909252600882018054949550929390926101208401916137ad90614b98565b80601f01602080910402602001604051908101604052809291908181526020018280546137d990614b98565b80156138265780601f106137fb57610100808354040283529160200191613826565b820191906000526020600020905b81548152906001019060200180831161380957829003601f168201915b505050918352505060098201546001600160a01b0381166020830152604090910190600160a01b900460ff16600381111561386357613863614529565b600381111561387457613874614529565b8152600a8201546020808301919091526040805160e081018252600b8501548152600c85015481840152600d85015481830152600e8501546060820152600f8501546080820152601085015460a082015260119094015460c08501529182019290925260008d8152601b90925281205491925060ff9091169080808361393e5784608001518610925082613909576000613919565b8585608001516139199190614bec565b91508215613928576000613937565b60808501516139379087614bec565b9050613966565b8460c001518610925082613953576000613963565b858560c001516139639190614bec565b91505b6139708987613b55565b61397d8560a00151614104565b919d919c509a509098509650505050505050565b600b546001600160a01b03163314806139b9575060065461010090046001600160a01b031633145b806139c357503033145b6139df5760405162461bcd60e51b8152600401610fc290614d60565b61133d8183613da2565b6000908152601a60205260409020546001600160a01b031690565b6000610f2082612e6e565b600b546001600160a01b0316331480613a37575060065461010090046001600160a01b031633145b80613a4157503033145b613a5d5760405162461bcd60e51b8152600401610fc290614d60565b60065460ff1615613a7457613a7182611103565b91505b60405163a9059cbb60e01b81526001600160a01b038281166004830152602482018490527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016120a3565b828202811515841585830485141716613ae157600080fd5b0492915050565b828202811515841585830485141716613b0057600080fd5b6001826001830304018115150290509392505050565b6006546000906001600160a01b03848116610100909204161480610eb2575050506001600160a01b031660009081526008602052604090205460ff1690565b6001600160a01b038216600090815260186020526040902060010154610100900460ff16613bbc5760405162461bcd60e51b8152602060048201526014602482015273155395149554d5115108125b9cdd1c9d5b595b9d60621b6044820152606401610fc2565b60065460ff1615613bd357613bd081611103565b90505b6001600160a01b03821660009081526018602052604081206002018054839290613bfe908490614bec565b9250508190555080600a6000828254613c179190614bec565b909155505060405163852a12e360e01b8152600481018290526001600160a01b0383169063852a12e3906024016020604051808303816000875af1158015613c63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c879190614d15565b613cc35760405162461bcd60e51b815260206004820152600d60248201526c14915111515357d19052531151609a1b6044820152606401610fc2565b6040518181526001600160a01b0383169033907fc8e1ada3e3428244364539f5fe21fa3bc368ed3634b0abc2355534eb12ca3524906020015b60405180910390a35050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051613d3a9190614dc5565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b6001600160a01b03821660009081526003602052604081208054839290613dca908490614bec565b90915550506002805482900390556040518181526000906001600160a01b03841690600080516020614e6283398151915290602001613cfc565b4260186000613e12846139e9565b6001600160a01b03166001600160a01b0316815260200190815260200160002060070154613e409190614b80565b60186000613e4d846139e9565b6001600160a01b031681526020810191909152604001600020600a015550565b6000610eb283670de0b6b3a764000084613ac9565b60006040516323b872dd60e01b81528460048201528360248201528260448201526020600060648360008a5af13d15601f3d1160016000511416171691505080613f055760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610fc2565b5050505050565b8060026000828254613f1e9190614b80565b90915550506001600160a01b038216600081815260036020908152604080832080548601905551848152600080516020614e628339815191529101613cfc565b613f6782611145565b61133d5760405162461bcd60e51b815260206004820152601c60248201527f4e6f7420656e6f756768206c6971756469747920696e207661756c74000000006044820152606401610fc2565b600060405163a9059cbb60e01b8152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061402b5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610fc2565b50505050565b60008380156140d15760018416801561404c57859250614050565b8392505b508260011c8460011c94505b84156140cb578560801c1561407057600080fd5b8586028181018181101561408357600080fd5b85900496505060018516156140c05785830283878204146140a95786156140a957600080fd5b818101818110156140b957600080fd5b8590049350505b8460011c945061405c565b506140e7565b8380156140e157600092506140e5565b8392505b505b509392505050565b6000610eb28383670de0b6b3a7640000613ac9565b6000818152601a60209081526040808320546001600160a01b031683526018909152902060048101546141795760405162461bcd60e51b815260206004820152601860248201527f696e737472756d656e7420646f65736e277420657869737400000000000000006044820152606401610fc2565b6000828152601a60209081526040808320546001600160a01b031683526018909152812081815560018101805461ffff19169055600281018290556003810182905560048101829055600581018290556006810182905560078101829055906141e56008830182614383565b506009810180546001600160a81b03191690556000600a8201819055600b8201819055600c8201819055600d8201819055600e8201819055600f820181905560108201819055601190910181905591825250601a6020526040902080546001600160a01b0319169055565b604080516101c08101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201526101408101829052906101608201908152602001600081526020016142fa6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b82805461430b90614b98565b90600052602060002090601f01602090048101928261432d5760008555614373565b82601f1061434657805160ff1916838001178555614373565b82800160010185558215614373579182015b82811115614373578251825591602001919060010190614358565b5061437f9291506143b9565b5090565b50805461438f90614b98565b6000825580601f1061439f575050565b601f0160209004906000526020600020908101906117e291905b5b8082111561437f57600081556001016143ba565b6000815180845260005b818110156143f4576020818501810151868301820152016143d8565b81811115614406576000602083870101525b50601f01601f19169290920160200192915050565b602081526000610eb260208301846143ce565b60006020828403121561444057600080fd5b5035919050565b6001600160a01b03811681146117e257600080fd5b803561446781614447565b919050565b6000806040838503121561447f57600080fd5b823561448a81614447565b946020939093013593505050565b6000602082840312156144aa57600080fd5b8135610eb281614447565b600080604083850312156144c857600080fd5b50508035926020909101359150565b80151581146117e257600080fd5b8035614467816144d7565b6000806040838503121561450357600080fd5b823561450e81614447565b9150602083013561451e816144d7565b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b6004811061455d57634e487b7160e01b600052602160045260246000fd5b9052565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c08301525050565b8e81528d151560208201528c151560408201528b60608201528a60808201528960a08201528860c08201528760e08201528661010082015261028061012082015260006145f66102808301886143ce565b6001600160a01b038716610140840152905061461661016083018661453f565b8361018083015261462b6101a0830184614561565b9f9e505050505050505050505050505050565b60008060006060848603121561465357600080fd5b833561465e81614447565b9250602084013561466e81614447565b929592945050506040919091013590565b60208152815160208201526000602083015161469f604084018215159052565b50604083015180151560608401525060608301516080830152608083015160a083015260a083015160c083015260c083015160e083015260e0830151610100818185015280850151915050610120818185015280850151915050610140610280818501526147116102a08501836143ce565b9085015190915061016061472f858201836001600160a01b03169052565b85015190506101806147438582018361453f565b8501516101a08581019190915285015190506140e76101c0850182614561565b634e487b7160e01b600052604160045260246000fd5b6040516101c0810167ffffffffffffffff8111828210171561479d5761479d614763565b60405290565b600080600083850360808112156147b957600080fd5b843593506040601f19820112156147cf57600080fd5b506040516040810181811067ffffffffffffffff821117156147f3576147f3614763565b60409081526020868101358352908601359082015291506060840135614818816144d7565b809150509250925092565b6000806040838503121561483657600080fd5b82359150602083013561451e81614447565b600082601f83011261485957600080fd5b813567ffffffffffffffff8082111561487457614874614763565b604051601f8301601f19908116603f0116810190828211818310171561489c5761489c614763565b816040528381528660208588010111156148b557600080fd5b836020870160208301376000602085830101528094505050505092915050565b80356004811061446757600080fd5b600060e082840312156148f657600080fd5b60405160e0810181811067ffffffffffffffff8211171561491957614919614763565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c08201525092915050565b60006020828403121561497a57600080fd5b813567ffffffffffffffff8082111561499257600080fd5b9083019061028082860312156149a757600080fd5b6149af614779565b823581526149bf602084016144e5565b60208201526149d0604084016144e5565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013583811115614a2757600080fd5b614a3388828701614848565b8284015250506101409150614a4982840161445c565b828201526101609150614a5d8284016148d5565b82820152610180915081830135828201526101a09150614a7f868385016148e4565b91810191909152949350505050565b600080600060608486031215614aa357600080fd5b833592506020840135614ab581614447565b9150604084013561481881614447565b600080600080600080600060e0888a031215614ae057600080fd5b8735614aeb81614447565b96506020880135614afb81614447565b95506040880135945060608801359350608088013560ff81168114614b1f57600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215614b4f57600080fd5b8235614b5a81614447565b9150602083013561451e81614447565b634e487b7160e01b600052601160045260246000fd5b60008219821115614b9357614b93614b6a565b500190565b600181811c90821680614bac57607f821691505b60208210811415614bcd57634e487b7160e01b600052602260045260246000fd5b50919050565b600060208284031215614be557600080fd5b5051919050565b600082821015614bfe57614bfe614b6a565b500390565b600181815b80851115614c3e578160001904821115614c2457614c24614b6a565b80851615614c3157918102915b93841c9390800290614c08565b509250929050565b600082614c5557506001610f20565b81614c6257506000610f20565b8160018114614c785760028114614c8257614c9e565b6001915050610f20565b60ff841115614c9357614c93614b6a565b50506001821b610f20565b5060208310610133831016604e8410600b8410161715614cc1575081810a610f20565b614ccb8383614c03565b8060001904821115614cdf57614cdf614b6a565b029392505050565b6000610eb28383614c46565b600082614d1057634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215614d2757600080fd5b8151610eb2816144d7565b600080600060608486031215614d4757600080fd5b8351925060208401519150604084015190509250925092565b60208082526011908201527034b9903737ba1031b7b73a3937b63632b960791b604082015260600190565b6000816000190483118215151615614da557614da5614b6a565b500290565b6000600019821415614dbe57614dbe614b6a565b5060010190565b600080835481600182811c915080831680614de157607f831692505b6020808410821415614e0157634e487b7160e01b86526022600452602486fd5b818015614e155760018114614e2657614e53565b60ff19861689528489019650614e53565b60008a81526020902060005b86811015614e4b5781548b820152908501908301614e32565b505084890196505b50949897505050505050505056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa26469706673582212200ee0846f4685a973cd65fc45f61290180b29cc1dfc3fb7e00685e0d2498000af64736f6c634300080c0033a264697066735822122002688620e74023ac2e11f2786398c6b32fb9e42f42a2f02d0d6d7d659b63fe0764736f6c634300080c0033",
  "devdoc": {
    "details": "only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent",
    "kind": "dev",
    "methods": {
      "newVault(address,address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "params": {
          "_asset_limit": ": max number of shares for a single address",
          "_controller": ": protocol controller",
          "_onlyVerified": ": only verified users can mint shares",
          "_r": ": minimum reputation score to mint shares",
          "_total_asset_limit": ": max number of shares for entire vault",
          "default_params": ": default params for markets created by vault",
          "underlying": ": underlying asset for vault"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "newVault(address,address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "notice": "creates vault"
      }
    },
    "notice": "Anyone can create a vault. These can be users who   a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans) b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers) c) a vault for any long-tailed assets  d) managers who wants leverage for yield opportunities on a specific asset  e) uncollateralized lending platforms that wants to delegate the risk underwriting  etc They need to specify  1. Vault mint conditions-> such as verified LPs(managers) only,  2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers) 3. Vault underlying ",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9227,
        "contract": "contracts/protocol/factories.sol:VaultFactory",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 9231,
        "contract": "contracts/protocol/factories.sol:VaultFactory",
        "label": "_isVault",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 9233,
        "contract": "contracts/protocol/factories.sol:VaultFactory",
        "label": "numVaults",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 9236,
        "contract": "contracts/protocol/factories.sol:VaultFactory",
        "label": "controller",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(Controller)9216"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Controller)9216": {
        "encoding": "inplace",
        "label": "contract Controller",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}